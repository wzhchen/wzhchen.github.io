<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="嵌入式开发"><title>QMI 拨号&amp;网口 | wzhchen's blog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">QMI 拨号&amp;网口</h1><a id="logo" href="/.">wzhchen's blog</a><p class="description">学习、记录、分享</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">QMI 拨号&amp;网口</h1><div class="post-meta"><a href="/芯片方案/mdm9x07/QMI 拨号&amp;网口/#comments" class="comment-count"></a><p><span class="date">Jul 20, 2019</span><span><a href="/categories/芯片方案/" class="category">芯片方案</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>记录 9x07平台的网口相关功能的研究过程，包含QMI、smd、网口等功能</p>
<a id="more"></a>
<h1 id="rmnet-USB网口"><a href="#rmnet-USB网口" class="headerlink" title="rmnet USB网口"></a>rmnet USB网口</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ol>
<li><p>创建5控制接口misc设备，供应用层使用</p>
<p>function初始化rmnet_function_init  —&gt;  rmnet_init   —&gt;   gqti_ctrl_init</p>
<p>rmnet_ctrl、rmnet_ctrl1、rmnet_ctrl2、rmnet_ctr3、dpl_ctrl</p>
</li>
<li><p>初始化USB端点</p>
<p>应用层：echo QTI,BAM_DMUX &gt;  f_rmnet/transports</p>
<p>frmnet_init_port，初始化网络接口设备和端口：f_rmnet、rmnet_port</p>
<ul>
<li>控制接口类型：QTI</li>
<li>数据接口类型：BAM_DMUX</li>
</ul>
<p>frmnet_bind，初始化function interface</p>
<p>创建3个endpoint</p>
<ul>
<li><p>数据TX，从机 —&gt; 主机（IN endpoint）</p>
</li>
<li><p>数据RX，主机 —&gt; 从机（OUT endpoint）</p>
</li>
<li><p>事件通知，从机 —&gt; 主机（IN endpoint）</p>
<p>初始接口和端点的描述</p>
</li>
</ul>
</li>
<li><p>通讯方式</p>
<p>应用层打开/dev/rmnet_ctrl和/dev/dpl_ctrl</p>
<p>应用层通过/dev/rmnet_ctrl和/dev/dpl_ctrl与host端程序通讯</p>
</li>
</ol>
<h2 id="设置接口"><a href="#设置接口" class="headerlink" title="设置接口"></a>设置接口</h2><p>usb连接时，host端驱动执行USB接口设置，触发frmnet_set_alt</p>
<ol>
<li>初始化&amp;打开<strong>事件通知</strong>端点</li>
<li>执行gport_rmnet_connect，连接初始化<ul>
<li>控制通道连接初始化</li>
<li>数据通道连接初始化</li>
</ul>
</li>
</ol>
<h3 id="控制通道连接初始化"><a href="#控制通道连接初始化" class="headerlink" title="控制通道连接初始化"></a>控制通道连接初始化</h3><p>gsmd_ctrl_connect</p>
<p>初始化2个回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_rmnet-&gt;send_encap_cmd = gqti_ctrl_send_cpkt_tomodem;</span><br><span class="line">g_rmnet-&gt;notify_modem = gqti_ctrl_notify_modem;</span><br></pre></td></tr></table></figure>
<p>执行g_rmnet-&gt;connect(port-&gt;port_usb)  —&gt;   frmnet_connect</p>
<h3 id="数据通道连接初始化"><a href="#数据通道连接初始化" class="headerlink" title="数据通道连接初始化"></a>数据通道连接初始化</h3><p><strong>gbam_connect</strong></p>
<p>初始化&amp;打开<strong>数据TX、数据RX</strong>端点</p>
<p>触发gbam_connect_work</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;port-&gt;connect_w, gbam_connect_work);	</span><br><span class="line">queue_work(gbam_wq, &amp;port-&gt;connect_w);</span><br></pre></td></tr></table></figure>
<p><strong>gbam_connect_work</strong></p>
<p>打开bam</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = msm_bam_dmux_open(d-&gt;id, port, gbam_notify);</span><br></pre></td></tr></table></figure>
<p>为TX和RX端口申请usb_request</p>
<p>gbam_start_io  —&gt;  _gbam_start_io  —&gt; gbam_alloc_requests</p>
<p>TX和RX端点的申请大小及完成回调</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in) &#123;</span><br><span class="line">    ep = port-&gt;port_usb-&gt;in;</span><br><span class="line">    idle = &amp;port-&gt;data_ch.tx_idle;</span><br><span class="line">    queue_size = bam_mux_tx_q_size;</span><br><span class="line">    ep_complete = gbam_epin_complete;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ep = port-&gt;port_usb-&gt;out;</span><br><span class="line">    <span class="keyword">if</span> (!ep)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    idle = &amp;port-&gt;data_ch.rx_idle;</span><br><span class="line">    queue_size = bam_mux_rx_q_size;</span><br><span class="line">    ep_complete = gbam_epout_complete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h2><h3 id="host向device发命令"><a href="#host向device发命令" class="headerlink" title="host向device发命令"></a>host向device发命令</h3><p><strong>host驱动</strong> —&gt;  <strong>usb </strong>—&gt;   <strong>device应用</strong></p>
<p>使用usb的setup，由frmnet_setup处理理</p>
<p>命令：USB_CDC_SEND_ENCAPSULATED_COMMAND</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">		| USB_CDC_SEND_ENCAPSULATED_COMMAND:</span><br><span class="line">	pr_debug(<span class="string">"%s: USB_CDC_SEND_ENCAPSULATED_COMMAND\n"</span></span><br><span class="line">			 , __func__);</span><br><span class="line">	ret = w_length;</span><br><span class="line">	req-&gt;complete = frmnet_cmd_complete;</span><br><span class="line">	req-&gt;context = dev;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>frmnet_cmd_complete   —&gt;   dev-&gt;port.send_encap_cmd  —&gt;  gqti_ctrl_send_cpkt_tomodem</p>
<p>其中参数port使用ctrl_xport_num</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> USB_GADGET_XPORT_QTI:</span><br><span class="line">rmnet_port-&gt;ctrl_xport_num = no_ctrl_qti_ports;</span><br><span class="line"><span class="comment">//此时ctrl_xport_num==0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;port.send_encap_cmd) &#123;</span><br><span class="line">	port_num = rmnet_ports[dev-&gt;port_num].ctrl_xport_num;</span><br><span class="line">	dev-&gt;port.send_encap_cmd(port_num, req-&gt;buf, req-&gt;actual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>gqti_ctrl_send_cpkt_tomodem</strong></p>
<p>将数据放到队列中，唤醒读取的任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port = ctrl_port[portno]; <span class="comment">//端口号为0，使用/dev/rmnet_ctrl</span></span><br><span class="line">cpkt = alloc_rmnet_ctrl_pkt(len, GFP_ATOMIC);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(cpkt-&gt;buf, buf, len);</span><br><span class="line">cpkt-&gt;len = len;</span><br><span class="line"></span><br><span class="line">list_add_tail(&amp;cpkt-&gt;<span class="built_in">list</span>, &amp;port-&gt;cpkt_req_q);</span><br><span class="line">wake_up(&amp;port-&gt;read_wq);</span><br></pre></td></tr></table></figure>
<p><strong>device应用读取</strong></p>
<p>qti_ctrl_read</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpkt = list_first_entry(&amp;port-&gt;cpkt_req_q, struct rmnet_ctrl_pkt,</span><br><span class="line">						<span class="built_in">list</span>);</span><br><span class="line">ret = copy_to_user(buf, cpkt-&gt;buf, cpkt-&gt;len);</span><br></pre></td></tr></table></figure>
<h3 id="device向host发命令"><a href="#device向host发命令" class="headerlink" title="device向host发命令"></a>device向host发命令</h3><p> <strong>device应用</strong> —&gt;  <strong>usb </strong>—&gt;  <strong>host驱动</strong></p>
<p>qti_ctrl_write</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = copy_from_user(kbuf, buf, count);</span><br><span class="line">ret = g_rmnet-&gt;send_cpkt_response(port-&gt;port_usb,</span><br><span class="line">                                  kbuf, count);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev-&gt;port.send_cpkt_response = frmnet_send_cpkt_response;</span><br></pre></td></tr></table></figure>
<p>frmnet_send_cpkt_response</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cpkt = rmnet_alloc_ctrl_pkt(len, GFP_ATOMIC);</span><br><span class="line"><span class="built_in">memcpy</span>(cpkt-&gt;buf, buf, len);</span><br><span class="line">cpkt-&gt;len = len;</span><br><span class="line"></span><br><span class="line">list_add_tail(&amp;cpkt-&gt;<span class="built_in">list</span>, &amp;dev-&gt;cpkt_resp_q);<span class="comment">//先将数据存起来</span></span><br><span class="line">frmnet_ctrl_response_available(dev);<span class="comment">//然后通过notify端点向host发消息</span></span><br></pre></td></tr></table></figure>
<p>host收到消息后再通过setup来取数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">		| USB_CDC_GET_ENCAPSULATED_RESPONSE:</span><br><span class="line">	pr_debug(<span class="string">"%s: USB_CDC_GET_ENCAPSULATED_RESPONSE\n"</span>, __func__);</span><br><span class="line">	</span><br><span class="line">    cpkt = list_first_entry(&amp;dev-&gt;cpkt_resp_q,</span><br><span class="line">    struct rmnet_ctrl_pkt, <span class="built_in">list</span>);</span><br><span class="line">    list_del(&amp;cpkt-&gt;<span class="built_in">list</span>);</span><br><span class="line">    spin_unlock(&amp;dev-&gt;lock);</span><br><span class="line"></span><br><span class="line">	len = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span>, w_length, cpkt-&gt;len);</span><br><span class="line">	<span class="built_in">memcpy</span>(req-&gt;buf, cpkt-&gt;buf, len);</span><br></pre></td></tr></table></figure>
<h3 id="host向device发数据"><a href="#host向device发数据" class="headerlink" title="host向device发数据"></a>host向device发数据</h3><p><strong>host驱动</strong> —&gt;  <strong>usb </strong>—&gt;   <strong>bam</strong> —&gt;  <strong>modem</strong></p>
<p>host通过数据RX端点(OUT)发数据</p>
<p>device收到数据，执行gbam_epout_complete</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">skb_put(skb, req-&gt;actual);</span><br><span class="line">__skb_queue_tail(&amp;d-&gt;rx_skb_q, skb);</span><br><span class="line"></span><br><span class="line">queue_work(gbam_wq, &amp;d-&gt;write_tobam_w);</span><br></pre></td></tr></table></figure>
<p>数据存放到链表，通知处理任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;d-&gt;write_tobam_w, gbam_data_write_tobam);</span><br></pre></td></tr></table></figure>
<p>gbam_data_write_tobam —&gt; msm_bam_dmux_write</p>
<h3 id="device向host发数据"><a href="#device向host发数据" class="headerlink" title="device向host发数据"></a>device向host发数据</h3><p><strong>modem</strong> —&gt;  <strong>bam</strong> —&gt; <strong>usb</strong>   —&gt;  <strong>host驱动</strong></p>
<ol>
<li>数据通道连接初始化时open bam时设置了回调gbam_notify</li>
<li>gbam_notify处理消息BAM_DMUX_RECEIVE</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (event) &#123;</span><br><span class="line"><span class="keyword">case</span> BAM_DMUX_RECEIVE:</span><br><span class="line">	skb = (struct sk_buff *)data;</span><br><span class="line">	<span class="keyword">if</span> (port)</span><br><span class="line">		gbam_data_recv_cb(p, skb);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		dev_kfree_skb_any(skb);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>gbam_data_recv_cb —&gt;  gbam_write_data_tohost</p>
<h1 id="BAM数据收发"><a href="#BAM数据收发" class="headerlink" title="BAM数据收发"></a>BAM数据收发</h1><p>bam支持的BAM通道非常多，USB用了其中2个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> bam_ch_ids[BAM_N_PORTS] = &#123;</span><br><span class="line">	BAM_DMUX_USB_RMNET_0,</span><br><span class="line">	BAM_DMUX_USB_DPL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化时申请了2个bam端口供usb使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gbam_port_alloc</span><span class="params">(<span class="keyword">int</span> portno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	port = kzalloc(<span class="keyword">sizeof</span>(struct gbam_port), GFP_KERNEL);</span><br><span class="line">	d-&gt;id = bam_ch_ids[portno];<span class="comment">//主要关注BAM_DMUX_USB_RMNET_0</span></span><br><span class="line"></span><br><span class="line">	bam_ports[portno].port = port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>gbam_data_write_tobam —&gt; msm_bam_dmux_write</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int msm_bam_dmux_write(uint32_t id, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	//填充数据包头</span><br><span class="line">	hdr = (struct bam_mux_hdr *)skb_push(skb, sizeof(struct bam_mux_hdr));</span><br><span class="line">	/* caller should allocate for hdr and padding</span><br><span class="line">	   hdr is fine, padding is tricky */</span><br><span class="line">	hdr-&gt;magic_num = BAM_MUX_HDR_MAGIC_NO;</span><br><span class="line">	hdr-&gt;cmd = BAM_MUX_HDR_CMD_DATA;</span><br><span class="line">	hdr-&gt;signal = 0;</span><br><span class="line">	hdr-&gt;ch_id = id;</span><br><span class="line">	hdr-&gt;pkt_len = skb-&gt;len - sizeof(struct bam_mux_hdr);</span><br><span class="line">	if (skb-&gt;len &amp; 0x3)</span><br><span class="line">		skb_put(skb, 4 - (skb-&gt;len &amp; 0x3));</span><br><span class="line">	//使用DMA发送	</span><br><span class="line">	pkt-&gt;skb = skb;</span><br><span class="line">	pkt-&gt;dma_address = dma_address;</span><br><span class="line">	pkt-&gt;is_cmd = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>bamr接收数据入口：__queue_rx  —&gt;  handle_bam_mux_cmd   —&gt; bam_mux_process_data</p>
<p>接收的数据包中通道ID，根据通道找到notify，msm_bam_dmux_open打开通道时传入</p>
<h1 id="modem-网口"><a href="#modem-网口" class="headerlink" title="modem 网口"></a>modem 网口</h1><h2 id="网口创建"><a href="#网口创建" class="headerlink" title="网口创建"></a>网口创建</h2><p><em>高通原始代码中网口名字不叫modem，面是rmnet_data</em></p>
<p>kernel初始化时默认没有创建rmnet网口</p>
<ol>
<li>rmnet创建入口：bam_rmnet_probe</li>
</ol>
<ul>
<li><p>kernel初始化时创建了bam_dmux_ch_xx（xx表示有很多）平台驱动</p>
</li>
<li><p>启动后收到了bam数据（命令：BAM_MUX_HDR_CMD_OPEN），添加平台设备bam_dmux_ch_0</p>
<p>handle_bam_mux_cmd —&gt;  handle_bam_mux_cmd_open —&gt; platform_device_add</p>
</li>
<li><p>触发bam_rmnet_probe</p>
<p>创建rmnet0网口，用于控制交互</p>
</li>
</ul>
<ol start="2">
<li>rmnet_data创建入口： rmnet_vnd_create_dev</li>
</ol>
<ul>
<li>rmnet_config_netlink_msg_handler –&gt;  rmnet_create_vnd –&gt;  rmnet_vnd_create_dev</li>
<li>创建8个网口，rmnet_data0 - rmnet_data7，用于数据收发</li>
</ul>
<ol start="3">
<li><p>netmgrd初始化,将rmnet和和rmnet_data绑定</p>
<p>使用 RMNET_NETLINK_SET_LOGICAL_EP_CONFIG命令</p>
<p>_rmnet_netlink_set_logical_ep_config –&gt; rmnet_set_logical_endpoint_config</p>
<p>将rmnet_data0的epconfig.egress_dev指向rmnet0</p>
</li>
</ol>
<h2 id="打开网口"><a href="#打开网口" class="headerlink" title="打开网口"></a>打开网口</h2><p>数据收发需要使用bam，因此需要打开bam</p>
<ol>
<li><p>netmgrd进程使用ioctl打开了rmnet0网口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">netmgr_kif_ifioctl_open_port (<span class="keyword">const</span> <span class="keyword">char</span> * dev)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Open a datagram socket to use for issuing the ioctl */</span></span><br><span class="line">  <span class="keyword">if</span> ((fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//此处使用的接口名为rmnet0</span></span><br><span class="line">  <span class="comment">/* Set device name in ioctl req struct */</span></span><br><span class="line">  (<span class="keyword">void</span>)strlcpy(ifr.ifr_name, dev, <span class="keyword">sizeof</span>(ifr.ifr_name));</span><br><span class="line">  <span class="comment">/* Get current if flags for the device */</span></span><br><span class="line">  <span class="keyword">if</span> (ioctl(fd, RMNET_IOCTL_OPEN, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>kernel中执行rmnet0网口的open操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rmnet_ioctl</span><span class="params">(struct net_device *dev, struct ifreq *ifr, <span class="keyword">int</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">case</span> RMNET_IOCTL_OPEN:              <span class="comment">/* Open transport port     */</span></span><br><span class="line">		rc = __rmnet_open(dev);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __rmnet_open(struct net_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rmnet_private</span> *<span class="title">p</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;device_up == DEVICE_UNINITIALIZED) &#123;</span><br><span class="line">		r = msm_bam_dmux_open(p-&gt;ch_id, dev, bam_notify);</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;device_up = DEVICE_ACTIVE;</span><br></pre></td></tr></table></figure>
<p>bam只打开一次，关闭接口时也不关闭bam</p>
</li>
</ol>
<h2 id="发送数据-1"><a href="#发送数据-1" class="headerlink" title="发送数据"></a>发送数据</h2><p>数据收发使用rmnet_data0接口（现已改名成modem）</p>
<p>rmnet_data0接口的发送函数：rmnet_vnd_start_xmit</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> netdev_tx_t <span class="title">rmnet_vnd_start_xmit</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">					struct net_device *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rmnet_vnd_private_s</span> *<span class="title">dev_conf</span>;</span></span><br><span class="line">	trace_rmnet_vnd_start_xmit(skb);</span><br><span class="line">	dev_conf = (struct rmnet_vnd_private_s *) netdev_priv(dev);</span><br><span class="line">	<span class="keyword">if</span> (dev_conf-&gt;local_ep.egress_dev) &#123;</span><br><span class="line">		<span class="comment">/* QoS header should come after MAP header */</span></span><br><span class="line">		<span class="keyword">if</span> (dev_conf-&gt;qos_version)</span><br><span class="line">			rmnet_vnd_add_qos_header(skb,</span><br><span class="line">						 dev,</span><br><span class="line">						 dev_conf-&gt;qos_version);</span><br><span class="line">		rmnet_egress_handler(skb, &amp;dev_conf-&gt;local_ep);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dev-&gt;stats.tx_dropped++;</span><br><span class="line">		rmnet_kfree_skb(skb, RMNET_STATS_SKBFREE_VND_NO_EGRESS);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NETDEV_TX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据由rmnet_egress_handler处理，其中dev_conf-&gt;local_ep.egress_dev在前面有初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmnet_egress_handler</span><span class="params">(struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">			  struct rmnet_logical_ep_conf_s *ep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rmnet_phys_ep_conf_s</span> *<span class="title">config</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">orig_dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line">	orig_dev = skb-&gt;dev;</span><br><span class="line">	skb-&gt;dev = ep-&gt;egress_dev; <span class="comment">//替换skb的设备，此时egress_dev为rmnet0</span></span><br><span class="line">	rc = dev_queue_xmit(skb); <span class="comment">//将skb存入rmnet0的队列中</span></span><br></pre></td></tr></table></figure>
<p>触发rmnet0的发送队列：rmnet_xmit  —&gt;  _rmnet_xmit  —&gt;  msm_bam_dmux_write</p>
<h2 id="接收数据-1"><a href="#接收数据-1" class="headerlink" title="接收数据"></a>接收数据</h2><p>打开bam时传入了notify函数bam_notify</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bam_notify</span><span class="params">(<span class="keyword">void</span> *dev, <span class="keyword">int</span> event, <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (event) &#123;</span><br><span class="line">	<span class="keyword">case</span> BAM_DMUX_RECEIVE:</span><br><span class="line">		bam_recv_notify(dev, (struct sk_buff *)(data));</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bam_recv_notify</span><span class="params">(<span class="keyword">void</span> *dev, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (skb) &#123;</span><br><span class="line">		skb-&gt;dev = dev;</span><br><span class="line">		netif_rx_ni(skb); <span class="comment">//数据包入协议栈</span></span><br></pre></td></tr></table></figure>
<p>rmnet处理数据包：__rmnet_deliver_skb</p>
<p>数据包从rmnet0进入协议栈，rmnet_data0会向协议栈注册一些回调用于数据包处理，比如更新rmnet_data0的统计值：rmnet_vnd_rx_fixup，</p>
<h1 id="qti数据处理"><a href="#qti数据处理" class="headerlink" title="qti数据处理"></a>qti数据处理</h1><p>应用层启动了一个qti进程，负责与host端的驱动交互，同时通过/dev/smdcntl8与modem交互</p>
<h2 id="qti接收host端数据"><a href="#qti接收host端数据" class="headerlink" title="qti接收host端数据"></a>qti接收host端数据</h2><p>host端发的数据通过/dev/rmnet_ctrl到达qti进程</p>
<p>数据由qti_rmnet_ph_recv_msg处理，再调用qti_rmnet_modem_send_msg处理</p>
<ol>
<li>数据交给qti_rmnet_process_qmi_tx_to_modem处理一遍（可能会修改数据）</li>
<li>数据转发给/dev/smdcntl8（发给modem）</li>
</ol>
<p><strong>注：</strong>首次接收到数据，需要打开&amp;初始化与modem侧的通信通道，否则smdcntl8不能通信</p>
<h2 id="qti接收modem数据"><a href="#qti接收modem数据" class="headerlink" title="qti接收modem数据"></a>qti接收modem数据</h2><p>modem发的数据通过/dev/smdcntl8到达qti进程</p>
<p>数据由qti_rmnet_modem_recv_msg处理</p>
<ol>
<li><p>数据交给qti_rmnet_process_qmi_rx_from_modem处理一遍</p>
<p>qti修改某些服务的数据后再转给host端</p>
</li>
<li><p>数据转发给/dev/rmnet_ctrl（发给host）</p>
</li>
</ol>
<h2 id="打开通信通道"><a href="#打开通信通道" class="headerlink" title="打开通信通道"></a>打开通信通道</h2><p>qti_rmnet_ph_recv_msg —&gt; qti_rmnet_process_ph_reset</p>
<ol>
<li><p>首先确认USB是否确实已经连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret = ioctl(rmnet_state_config-&gt;ph_iface[PH_DRIVER_TYPE_USB].ph_iface_fd,</span><br><span class="line">            FRMNET_CTRL_GET_LINE_STATE, &amp;line_state);</span><br></pre></td></tr></table></figure>
</li>
<li><p>已连接且通道没有打开，则执行打开&amp;初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(line_state == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rmnet_state_config-&gt;dtr_enabled)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//向dpm服务发请求，打开DATA40_CNTL通道</span></span><br><span class="line">        ret_val = qti_rmnet_dpm_port_open();</span><br><span class="line">        <span class="comment">//打开smdcntl8接口，绑定qti_rmnet_modem_recv_msg处理modem的数据</span></span><br><span class="line">        <span class="keyword">if</span>(qti_rmnet_modem_init(rmnet_state_config,</span><br><span class="line">                                dpl_state_config) &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        rmnet_state_config-&gt;dtr_enabled = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>打开DATA40_CNTL通道后会触发Kernel里创建SDM设备（<strong>SDM</strong>里有描述）</p>
</li>
<li><p>dpm服务的初始化</p>
<p>进程启动时调用了qti_dpm_init，初始化了DMP qmi客户端</p>
<p>QMI的初始化在<strong>QMI客户端</strong></p>
</li>
</ol>
<h1 id="qmuxd进程"><a href="#qmuxd进程" class="headerlink" title="qmuxd进程"></a>qmuxd进程</h1><p>qmuxd进程提供qmi服务</p>
<ol>
<li><p>qmuxd创建/tmp/qmux_connect_socket供客户端使用<br>linux_qmi_qmux_if_get_listener_socket</p>
</li>
<li><p>linux_qmi_qmux_if_configure_ports，默认关闭了所以端口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Disabling all channels initially to enable only required channels later.*/</span></span><br><span class="line"><span class="keyword">for</span> (i = QMI_CONN_ID_RMNET_0; i &lt; LINUX_QMI_MAX_CONN_SUPPORTED; i++)</span><br><span class="line">&#123;</span><br><span class="line">  qmi_qmux_disable_port(linux_qmi_conn_id_enablement_array[i].qmi_conn_id,</span><br><span class="line">      linux_qmi_conn_id_enablement_array[i].data_ctl_port, TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户通过qmux_connect_socket连接qmuxd</p>
<ul>
<li>为客户端分配一个id：qmux_client_id</li>
<li>将qmux_client_id发给客户端，后续客户端需要用这个id来通讯</li>
<li>qmuxd为客户端创建数据结构，更新linux_qmi_qmux_if_client_id_array</li>
</ul>
</li>
<li><p>客户端发数据</p>
<ul>
<li>client进程 —&gt;  qmux_connect_socket  —&gt;  qmuxd进程</li>
<li>qmuxd进程使用qmux_client_id（连接时分配的）发数据，处理函数：qmi_qmux_tx_msg</li>
<li>client发数据的消息头里包含qmi_conn_id，既数据发给谁，默认rmnet0<ul>
<li>qmi_qmux_if_internal_use_conn_id</li>
</ul>
</li>
<li>客户商使用qmi_qmux_if_send_to_qmux函数发数据<ul>
<li>最终调用 使用linux_qmi_qmux_if_client_tx_msg</li>
<li>数据面使用qmi_qmux_if_send_qmi_msg（msg_id固定为QMI_QMUX_IF_QMI_MSG_ID）</li>
<li>控制面使用qmi_qmux_if_send_if_msg_to_qmux（可指定msg_id）</li>
</ul>
</li>
</ul>
</li>
<li><p>qmuxd接收客户端的消息</p>
<ul>
<li>main中从客户端接收数据：linux_qmi_qmux_if_server_process_client_msg</li>
<li>使用qmi_qmux_tx_msg转发到消息</li>
</ul>
</li>
<li><p>qmuxd处理客户端数据：qmi_qmux_tx_msg</p>
<ul>
<li><p>第一次需要连接：qmi_qmux_open_connection —&gt; linux_qmi_qmux_io_open_conn</p>
<p><strong>因为默认所有的端口都被关闭，因此默认连接不成功</strong></p>
<p><em>默认客户端使用rmnet0</em></p>
</li>
<li><p>按照客户使用的msg_id做不同分类处理</p>
<ul>
<li>客户数据面使用QMI_QMUX_IF_QMI_MSG_ID，数据转发到modem<ul>
<li>由qmi_qmux_tx_to_modem处理</li>
<li>默认使用rmnet0，对应的控制节点为/dev/smdctl0</li>
<li><strong>因为端口默认是关闭的，正常数据不会被发送</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="qmi客户端"><a href="#qmi客户端" class="headerlink" title="qmi客户端"></a>qmi客户端</h1><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>libqmiserver.so中有函数void __attribute__ ((constructor)) qmi_fw_cci_init(void)，在main函数之前就运行，添加了一些port到xport_tbl，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qmi_cci_xport_start(&amp;qcci_ipc_router_ops, <span class="literal">NULL</span>);<span class="comment">//最先添加，优先使用</span></span><br><span class="line">qmi_cci_xport_start(&amp;qmuxd_ops, (<span class="keyword">void</span> *)QMI_CLIENT_QMUX_RMNET_INSTANCE_0);</span><br><span class="line">qmi_cci_xport_start(&amp;qmuxd_ops, (<span class="keyword">void</span> *)QMI_CLIENT_QMUX_RMNET_USB_INSTANCE_0);</span><br><span class="line">qmi_cci_xport_start(&amp;qmuxd_ops, (<span class="keyword">void</span> *)QMI_CLIENT_QMUX_RMNET_SMUX_INSTANCE_0);</span><br><span class="line">qmi_cci_xport_start(&amp;qmuxd_ops, (<span class="keyword">void</span> *)QMI_CLIENT_QMUX_RMNET_MHI_INSTANCE_0);</span><br></pre></td></tr></table></figure>
<p>qmi_client_init_instance  —&gt;  qmi_client_get_service_instance  —&gt;  qmi_client_get_service_list查的服务</p>
<ul>
<li>遍历xport_tbl表，使用lookup函数(xport_lookup)查找服务</li>
<li>qmi_client_init初始化客户端</li>
</ul>
<p><strong>xport_lookup</strong></p>
<p>优先使用qcci_ipc_router_ops的xport_lookup</p>
<ul>
<li>通过AF_MSM_IPC连接到内核</li>
<li>使用ioctl（命令：IPC_ROUTER_IOCTL_LOOKUP_SERVER）从内核查找服务</li>
<li>查找使用service（服务ID）和instance（服务版本）<ul>
<li>内核提供的服务查看文件：/sys/kernel/debug/msm_ipc_route/dump_servers</li>
</ul>
</li>
</ul>
<p>其次使用qmuxd_ops的xport_lookup</p>
<ul>
<li><p>查找之前需要边连接qmuxd</p>
<ul>
<li><p>如果连接不上(qmuxd进程没有启动)则等待1分钟,尝试60次</p>
</li>
<li><p>qmuxd里关闭了接口，实际不生效，获取不到服务</p>
<p><strong>注</strong>:虽然实际没使用qmuxd,但qmuxd进程不启动时会导致客户端每次请求等待1分钟</p>
</li>
</ul>
</li>
</ul>
<p><strong>qmi_client_init</strong></p>
<ol>
<li><p>找出服务提供者，默认服务由qcci_ipc_router_ops提供</p>
</li>
<li><p>初始化客户端内部使用的clnt，细节在qmi_cci_client_alloc里</p>
</li>
<li><p>打开服务，ops-&gt;open —&gt;   xport_open</p>
</li>
<li>保存open的返回句柄，给后续使用</li>
</ol>
<p><strong>xport_open</strong></p>
<p>获取服务时得到一个地址addr，后续数据通讯使用这个地址</p>
<p>服务由qcci_ipc_router_ops，所有的操作路由到kernel，由kernel处理</p>
<ol>
<li><p>初始化<strong>控制消息</strong>read线程：ctrl_msg_reader_thread</p>
<ul>
<li><p>进程只有一个控消息线程</p>
</li>
<li><p>打开socket，得到到fd，给线程用</p>
</li>
<li>发命令IPC_ROUTER_IOCTL_BIND_CONTROL_PORT到kernel</li>
<li>创建线程</li>
</ul>
</li>
<li><p>初始化<strong>数据消息</strong>read线程：data_msg_reader_thread</p>
<ul>
<li>进程可以有多个数据息线程</li>
<li>打开socket，得到到fd，给线程用</li>
<li>创建线程</li>
</ul>
</li>
</ol>
<h2 id="发送数据-2"><a href="#发送数据-2" class="headerlink" title="发送数据"></a>发送数据</h2><p>qmi_client_send_msg_sync</p>
<ul>
<li>根据handle找出clnt（在qmi_cci_client_alloc中创建）</li>
<li>从clnt中找到xport（在qmi_client_init中添加，在qmi_client_get_service_instance中初始化)</li>
<li>数据编码&amp;发送：encode_and_send</li>
<li>使用qmi_cci_send发送数据</li>
<li>使用服务提供的send发送数据：xport_send</li>
<li>数据发给kernel（携带了服务地址）</li>
<li>等待数据回应：qmi_cci_response_wait_loop<ul>
<li><strong>数据消息</strong>read线程会通知当前线程</li>
</ul>
</li>
</ul>
<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>data_msg_reader_thread</p>
<ul>
<li>从kernel读取数据，转发到应用程序</li>
<li>从kernel读取控制消息，主要用于服务通知<ul>
<li>如果服务启动晚于应用初始化，qmi_client_init_instance 会等待服务</li>
</ul>
</li>
</ul>
<h1 id="ipc-router"><a href="#ipc-router" class="headerlink" title="ipc router"></a>ipc router</h1><p>从名字上看是进程间通讯路由功能，实际是实现了一个sock通讯</p>
<p>server  <---->  ipc sock core  <---->  client</----></----></p>
<h2 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h2><p>sock_register(&amp;msm_ipc_family_ops)</p>
<p>注册IPC sock类型，名字为MSM_IPC</p>
<h2 id="添加诊断服务"><a href="#添加诊断服务" class="headerlink" title="添加诊断服务"></a>添加诊断服务</h2><p><em>诊断服务不是重点，不关注细节</em></p>
<p>kernel启动时注册了许多诊断服务：diag_socket_init  —&gt;   __diag_socket_init</p>
<p>服务地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info-&gt;svc_id = DIAG_SVC_ID;</span><br><span class="line">info-&gt;ins_id = ins_base + ins_offset;</span><br></pre></td></tr></table></figure>
<p>诊断服务的创建：socket_open_server</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">info-&gt;hdl-&gt;sk-&gt;sk_data_ready = socket_data_ready;</span><br><span class="line">info-&gt;hdl-&gt;sk-&gt;sk_write_space = socket_flow_cntl;</span><br><span class="line"></span><br><span class="line">srv_addr.family = AF_MSM_IPC;</span><br><span class="line">srv_addr.address.addrtype = MSM_IPC_ADDR_NAME;</span><br><span class="line">srv_addr.address.addr.port_name.service = info-&gt;svc_id;</span><br><span class="line">srv_addr.address.addr.port_name.instance = info-&gt;ins_id;</span><br><span class="line"></span><br><span class="line">ret = kernel_bind(info-&gt;hdl, (struct sockaddr *)&amp;srv_addr,</span><br><span class="line">			  <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">----------&gt;</span><br><span class="line">msm_ipc_router_bind</span><br><span class="line">msm_ipc_router_register_server</span><br></pre></td></tr></table></figure>
<h2 id="QMI服务注册"><a href="#QMI服务注册" class="headerlink" title="QMI服务注册"></a>QMI服务注册</h2><p>modem 发送请求 —-&gt;  linux创建服务</p>
<p>modem给linux发命令:IPC_ROUTER_CTRL_CMD_NEW_SERVER,linux侧添加服务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IPC_ROUTER_CTRL_CMD_NEW_SERVER:</span><br><span class="line">	rc = process_new_server_msg(xprt_info, msg, pkt);</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>新建服务时使用xprt_info，后续客户端收发数据使用xprt_info-&gt;xprt提供的接口</p>
<p><strong>process_new_server_msg </strong></p>
<p>使用服务的ID(node_id, port_id)创建entry和port供后续查找数据结构使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rt_entry = ipc_router_get_rtentry_ref(msg-&gt;srv.node_id);</span><br><span class="line"><span class="keyword">if</span> (!rt_entry) &#123;</span><br><span class="line">    rt_entry = create_routing_table_entry(msg-&gt;srv.node_id,</span><br><span class="line">                                          xprt_info);</span><br><span class="line">&#125;</span><br><span class="line">rport_ptr = ipc_router_create_rport(msg-&gt;srv.node_id,</span><br><span class="line">			msg-&gt;srv.port_id, xprt_info);</span><br></pre></td></tr></table></figure>
<p>使用服务地址(service, instance)创建服务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server = msm_ipc_router_create_server(</span><br><span class="line">		msg-&gt;srv.service, msg-&gt;srv.instance,</span><br><span class="line">		msg-&gt;srv.node_id, msg-&gt;srv.port_id, xprt_info);</span><br></pre></td></tr></table></figure>
<p>xprt_info和modem数据如何达到linux侧的细节在后面讲</p>
<h2 id="ipc-route-smd"><a href="#ipc-route-smd" class="headerlink" title="ipc route smd"></a>ipc route smd</h2><p>实现linux侧数据与共享内存设备（包含modem）数据交互，以modem举例</p>
<p>server(modem)  <---->  ipc sock core  <---->  client(应用app)</----></----></p>
<h3 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h3><p>msm_ipc_router_smd_xprt_init，添加平台驱动：ipc_router_smd_xprt</p>
<p>设备树配置</p>
<pre><code>qcom,ipc_router_modem_xprt {
    compatible = &quot;qcom,ipc_router_smd_xprt&quot;;
    qcom,ch-name = &quot;IPCRTR&quot;;
    qcom,xprt-remote = &quot;modem&quot;;
    qcom,xprt-linkid = &lt;1&gt;;
    qcom,xprt-version = &lt;1&gt;;
    qcom,fragmented-data;
    qcom,disable-pil-loading;
};
</code></pre><p>probe时初始化服务： msm_ipc_router_smd_xprt_probe  —&gt;  msm_ipc_router_smd_config_init</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_ipc_router_smd_config_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		struct msm_ipc_router_smd_xprt_config *smd_xprt_config)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msm_ipc_router_smd_xprt</span> *<span class="title">smd_xprtp</span>;</span></span><br><span class="line"></span><br><span class="line">	smd_xprtp = kzalloc(<span class="keyword">sizeof</span>(struct msm_ipc_router_smd_xprt), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR_OR_NULL(smd_xprtp)) &#123;</span><br><span class="line">		IPC_RTR_ERR(<span class="string">"%s: kzalloc() failed for smd_xprtp id:%s\n"</span>,</span><br><span class="line">				__func__, smd_xprt_config-&gt;ch_name);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	smd_xprtp-&gt;xprt.link_id = smd_xprt_config-&gt;link_id;</span><br><span class="line">	smd_xprtp-&gt;xprt_version = smd_xprt_config-&gt;xprt_version;</span><br><span class="line">	smd_xprtp-&gt;edge = smd_xprt_config-&gt;edge;</span><br><span class="line">	smd_xprtp-&gt;xprt_option = smd_xprt_config-&gt;xprt_option;</span><br><span class="line">	smd_xprtp-&gt;disable_pil_loading = smd_xprt_config-&gt;disable_pil_loading;</span><br><span class="line"></span><br><span class="line">	strlcpy(smd_xprtp-&gt;ch_name, smd_xprt_config-&gt;ch_name,</span><br><span class="line">						SMD_MAX_CH_NAME_LEN);</span><br><span class="line"></span><br><span class="line">	strlcpy(smd_xprtp-&gt;xprt_name, smd_xprt_config-&gt;xprt_name,</span><br><span class="line">						XPRT_NAME_LEN);</span><br><span class="line">	smd_xprtp-&gt;xprt.name = smd_xprtp-&gt;xprt_name;</span><br><span class="line"></span><br><span class="line">	smd_xprtp-&gt;xprt.set_version =</span><br><span class="line">		ipc_router_smd_set_xprt_version;</span><br><span class="line">	smd_xprtp-&gt;xprt.get_version =</span><br><span class="line">		msm_ipc_router_smd_get_xprt_version;</span><br><span class="line">	smd_xprtp-&gt;xprt.get_option =</span><br><span class="line">		msm_ipc_router_smd_get_xprt_option;</span><br><span class="line">	smd_xprtp-&gt;xprt.read_avail = <span class="literal">NULL</span>;</span><br><span class="line">	smd_xprtp-&gt;xprt.read = <span class="literal">NULL</span>;</span><br><span class="line">	smd_xprtp-&gt;xprt.write_avail =</span><br><span class="line">		msm_ipc_router_smd_remote_write_avail;</span><br><span class="line">	smd_xprtp-&gt;xprt.write = msm_ipc_router_smd_remote_write;<span class="comment">//客户端的数据由write发给smd</span></span><br><span class="line">	smd_xprtp-&gt;xprt.close = msm_ipc_router_smd_remote_close;</span><br><span class="line">	smd_xprtp-&gt;xprt.sft_close_done = smd_xprt_sft_close_done;</span><br><span class="line">	smd_xprtp-&gt;xprt.priv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	init_waitqueue_head(&amp;smd_xprtp-&gt;write_avail_wait_q);</span><br><span class="line">	smd_xprtp-&gt;in_pkt = <span class="literal">NULL</span>;</span><br><span class="line">	smd_xprtp-&gt;is_partial_in_pkt = <span class="number">0</span>;</span><br><span class="line">	INIT_DELAYED_WORK(&amp;smd_xprtp-&gt;read_work, smd_xprt_read_data);<span class="comment">//从远端读取数据</span></span><br><span class="line">	spin_lock_init(&amp;smd_xprtp-&gt;ss_reset_lock);</span><br><span class="line">	smd_xprtp-&gt;ss_reset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	msm_ipc_router_smd_driver_register(smd_xprtp);<span class="comment">//注册驱动</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用设备树里的名字<strong>IPCRTR</strong>注册平台驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_ipc_router_smd_driver_register</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			struct msm_ipc_router_smd_xprt *smd_xprtp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msm_ipc_router_smd_xprt</span> *<span class="title">item</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> already_registered = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;smd_remote_xprt_list_lock_lha1);</span><br><span class="line">	list_for_each_entry(item, &amp;smd_remote_xprt_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(smd_xprtp-&gt;ch_name, item-&gt;ch_name))</span><br><span class="line">			already_registered = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	list_add(&amp;smd_xprtp-&gt;<span class="built_in">list</span>, &amp;smd_remote_xprt_list);</span><br><span class="line">	mutex_unlock(&amp;smd_remote_xprt_list_lock_lha1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!already_registered) &#123;</span><br><span class="line">		smd_xprtp-&gt;driver.driver.name = smd_xprtp-&gt;ch_name;</span><br><span class="line">		smd_xprtp-&gt;driver.driver.owner = THIS_MODULE;</span><br><span class="line">		smd_xprtp-&gt;driver.probe = msm_ipc_router_smd_remote_probe;</span><br><span class="line"></span><br><span class="line">		ret = platform_driver_register(&amp;smd_xprtp-&gt;driver);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			IPC_RTR_ERR(</span><br><span class="line">			<span class="string">"%s: Failed to register platform driver [%s]\n"</span>,</span><br><span class="line">						__func__, smd_xprtp-&gt;ch_name);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		IPC_RTR_ERR(<span class="string">"%s Already driver registered %s\n"</span>,</span><br><span class="line">					__func__, smd_xprtp-&gt;ch_name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果创建IPCRTR平台设备，触发msm_ipc_router_smd_remote_probe</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_ipc_router_smd_remote_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	smd_xprtp = find_smd_xprt_list(pdev);</span><br><span class="line">    smd_xprtp-&gt;pil = msm_ipc_load_subsystem(</span><br><span class="line">                    smd_xprtp-&gt;edge);</span><br><span class="line">    rc = smd_named_open_on_edge(smd_xprtp-&gt;ch_name,</span><br><span class="line">			    smd_xprtp-&gt;edge,</span><br><span class="line">			    &amp;smd_xprtp-&gt;channel,</span><br><span class="line">			    smd_xprtp,</span><br><span class="line">			    msm_ipc_router_smd_remote_notify);</span><br><span class="line">    <span class="comment">//modem有数据发给linux时，触发msm_ipc_router_smd_remote_notify</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：此处需要一个IPCRTR平台设备才能触发probe，IPCRTR设备在哪里创建？</strong></p>
<p>IPCRTR平台设备的创建在SDM里</p>
<h2 id="QMI数据收发"><a href="#QMI数据收发" class="headerlink" title="QMI数据收发"></a>QMI数据收发</h2><h3 id="发送数据-3"><a href="#发送数据-3" class="headerlink" title="发送数据"></a>发送数据</h3><p>应用层发数据到达qcci_ipc_router_ops-&gt;xport_send，细节在<a href="">qmi客户端</a>有讲</p>
<p>xport_send的数据到到kernel的msm_ipc_router_sendmsg</p>
<ul>
<li>xport_send发数据时携带了服务地址，数据由kernel路由到指定的服务</li>
<li>msm_ipc_router_sendmsg发数据时携带源端口（包含client进程sock信息）</li>
</ul>
<p>继续调用发送：msm_ipc_router_send_to</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//构造数据包</span></span><br><span class="line">pkt = create_pkt(data); </span><br><span class="line">...</span><br><span class="line"><span class="comment">//发送报文</span></span><br><span class="line">ret = msm_ipc_router_write_pkt(src, rport_ptr, pkt, timeout);</span><br></pre></td></tr></table></figure>
<p>填充包头&amp;发送：msm_ipc_router_write_pkt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hdr = &amp;(pkt-&gt;hdr);</span><br><span class="line">hdr-&gt;version = IPC_ROUTER_V1;</span><br><span class="line">hdr-&gt;type = IPC_ROUTER_CTRL_CMD_DATA;</span><br><span class="line">hdr-&gt;src_node_id = src-&gt;this_port.node_id;</span><br><span class="line">hdr-&gt;src_port_id = src-&gt;this_port.port_id;</span><br><span class="line">hdr-&gt;size = pkt-&gt;length;</span><br><span class="line">hdr-&gt;control_flag = <span class="number">0</span>;</span><br><span class="line">hdr-&gt;dst_node_id = rport_ptr-&gt;node_id;</span><br><span class="line">hdr-&gt;dst_port_id = rport_ptr-&gt;port_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用*/</span></span><br><span class="line">ret = xprt_info-&gt;xprt-&gt;write(pkt, pkt-&gt;length, xprt_info-&gt;xprt);</span><br></pre></td></tr></table></figure>
<p>其中 xprt_info-&gt;xprt在msm_ipc_router_smd_config_init中创建，对应的write函数为</p>
<p>msm_ipc_router_smd_remote_write  —&gt;    smd_write_segment</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int smd_write_segment(smd_channel_t *ch, const void *data, int len)</span><br><span class="line">&#123;</span><br><span class="line">	bytes_written = smd_stream_write(ch, data, len, true);</span><br><span class="line">	//其中ch在smd_alloc_channel中创建，对应的通道为IPCRTR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收数据-2"><a href="#接收数据-2" class="headerlink" title="接收数据"></a>接收数据</h3><p>就用层打开IPC_MSM类型的sock，从kernel的msm_ipc_router_recvmsg接收数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_ipc_router_recvmsg</span><span class="params">(struct kiocb *iocb, struct socket *sock,</span></span></span><br><span class="line"><span class="function"><span class="params">				  struct msghdr *m, <span class="keyword">size_t</span> buf_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//等待数据</span></span><br><span class="line">	ret = msm_ipc_router_rx_data_wait(port_ptr, timeout);</span><br><span class="line">	<span class="comment">//读取数据</span></span><br><span class="line">	ret = msm_ipc_router_read(port_ptr, &amp;pkt, buf_len);</span><br><span class="line">	<span class="comment">//解析数据</span></span><br><span class="line">	ret = msm_ipc_router_extract_msg(m, pkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取数据，从列队中取出数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msm_ipc_router_read</span><span class="params">(struct msm_ipc_port *port_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct rr_packet **read_pkt,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">size_t</span> buf_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pkt = list_first_entry(&amp;port_ptr-&gt;port_rx_q, struct rr_packet, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是数据怎么放入队列中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read_data</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	post_pkt_to_port(port_ptr, pkt, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">post_pkt_to_port</span><span class="params">(struct msm_ipc_port *port_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">			    struct rr_packet *pkt, <span class="keyword">int</span> clone)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list_add_tail(&amp;temp_pkt-&gt;<span class="built_in">list</span>, &amp;port_ptr-&gt;port_rx_q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中do_read_data的调用在<strong>Modem发数据到Linux</strong>有详细说明</p>
<h3 id="加密认证"><a href="#加密认证" class="headerlink" title="加密认证"></a>加密认证</h3><p>客户端发送数据之前需要配置加密认证方式，否则不能发数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int msm_ipc_router_sendmsg(struct kiocb *iocb, struct socket *sock,</span><br><span class="line">				  struct msghdr *m, size_t total_len)</span><br><span class="line">&#123;</span><br><span class="line">    if (port_ptr-&gt;type == CLIENT_PORT)</span><br><span class="line">        wait_for_irsc_completion(); //会一直等待认证配置完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认证配置由应用层irsc_util进程负责</p>
<h2 id="irsc-util"><a href="#irsc-util" class="headerlink" title="irsc_util"></a>irsc_util</h2><p>ipc router转发数据之前需要配置加密，irsc_util进程负责设置配置</p>
<p>系统启动时执行：/usr/bin/irsc_util /etc/sec_config</p>
<p>默认情况不存在/etc/sec_config文件，则使用默认配置</p>
<p>irsc_util代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fd = socket(AF_MSM_IPC, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!irsc_d-&gt;sec_info || !irsc_d-&gt;sec_info-&gt;num_entries) &#123;</span><br><span class="line">    arg = <span class="built_in">calloc</span>(<span class="number">1</span>, (<span class="keyword">sizeof</span>(*arg) + <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (!arg) &#123;</span><br><span class="line">        IRSC_ERR(<span class="string">"Calloc failure, Config feeding error\n"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> IRSC_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有配置，发送IPC_ROUTER_IOCTL_CONFIG_SEC_RULES命令，使用启用默认配置</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, IPC_ROUTER_IOCTL_CONFIG_SEC_RULES命令，, arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        IRSC_DEBUG(<span class="string">"Absent/Invalid config,Default rules apply\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> IRSC_INVALID_FILE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入到内核代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IPC_ROUTER_IOCTL_CONFIG_SEC_RULES:</span><br><span class="line">	ret = msm_ipc_config_sec_rules((<span class="keyword">void</span> *)arg);</span><br><span class="line">	<span class="keyword">if</span> (ret != -EPERM)</span><br><span class="line">		port_ptr-&gt;type = IRSC_PORT;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//socket关闭时</span></span><br><span class="line">	<span class="keyword">if</span> (port_ptr-&gt;type == IRSC_PORT) &#123;</span><br><span class="line">		down_write(&amp;local_ports_lock_lhc2);</span><br><span class="line">		list_del(&amp;port_ptr-&gt;<span class="built_in">list</span>);</span><br><span class="line">		up_write(&amp;local_ports_lock_lhc2);</span><br><span class="line">		signal_irsc_completion(); <span class="comment">//通知irsc完成</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Modem发数据到Linux"><a href="#Modem发数据到Linux" class="headerlink" title="Modem发数据到Linux"></a>Modem发数据到Linux</h1><p>modem发数据给linux总体思路</p>
<ul>
<li>数据存入共享内存</li>
<li>通知AP侧（linux侧）的CPU</li>
<li>AP侧CPU收到中断</li>
<li>中断中处理数据：handle_smd_irq</li>
</ul>
<p>具体数据处理函数在smd_alloc_channel注册</p>
<h2 id="modem侧打开端口"><a href="#modem侧打开端口" class="headerlink" title="modem侧打开端口"></a>modem侧打开端口</h2><p>modem发数据之前发送打开端口命令，触发msm_ipc_router_smd_remote_notify</p>
<p>事件是SMD_EVENT_OPEN</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SMD_EVENT_OPEN:</span><br><span class="line">	xprt_work = kmalloc(<span class="keyword">sizeof</span>(struct msm_ipc_router_smd_xprt_work),</span><br><span class="line">			    GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!xprt_work) &#123;</span><br><span class="line">		IPC_RTR_ERR(</span><br><span class="line">		<span class="string">"%s: Couldn't notify %d event to IPC Router\n"</span>,</span><br><span class="line">			__func__, event);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后续数据收发使用xprt_work-&gt;xprt，即使用smd提供的xprt</span></span><br><span class="line">	xprt_work-&gt;xprt = &amp;smd_xprtp-&gt;xprt;</span><br><span class="line">	INIT_WORK(&amp;xprt_work-&gt;work, smd_xprt_open_event);</span><br><span class="line">	queue_work(smd_xprtp-&gt;smd_xprt_wq, &amp;xprt_work-&gt;work);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>继续执行打开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">smd_xprt_open_event</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msm_ipc_router_smd_xprt_work</span> *<span class="title">xprt_work</span> =</span></span><br><span class="line"><span class="class">		<span class="title">container_of</span>(<span class="title">work</span>, <span class="title">struct</span> <span class="title">msm_ipc_router_smd_xprt_work</span>, <span class="title">work</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msm_ipc_router_smd_xprt</span> *<span class="title">smd_xprtp</span> =</span></span><br><span class="line"><span class="class">		<span class="title">container_of</span>(<span class="title">xprt_work</span>-&gt;<span class="title">xprt</span>,</span></span><br><span class="line"><span class="class">			     <span class="title">struct</span> <span class="title">msm_ipc_router_smd_xprt</span>, <span class="title">xprt</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;smd_xprtp-&gt;ss_reset_lock, flags);</span><br><span class="line">	smd_xprtp-&gt;ss_reset = <span class="number">0</span>;</span><br><span class="line">	spin_unlock_irqrestore(&amp;smd_xprtp-&gt;ss_reset_lock, flags);</span><br><span class="line">	msm_ipc_router_xprt_notify(xprt_work-&gt;xprt,<span class="comment">//后续数据收发使用xprt_work-&gt;xprt</span></span><br><span class="line">				IPC_ROUTER_XPRT_EVENT_OPEN, <span class="literal">NULL</span>); <span class="comment">//打开命令</span></span><br><span class="line">	D(<span class="string">"%s: Notified IPC Router of %s OPEN\n"</span>,</span><br><span class="line">	   __func__, xprt_work-&gt;xprt-&gt;name);</span><br><span class="line">	kfree(xprt_work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续打开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IPC_ROUTER_XPRT_EVENT_OPEN:</span><br><span class="line">	xprt_work = kmalloc(<span class="keyword">sizeof</span>(struct msm_ipc_router_xprt_work),</span><br><span class="line">			GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (xprt_work) &#123;</span><br><span class="line">		xprt_work-&gt;xprt = xprt;<span class="comment">//后续数据收发使用这个</span></span><br><span class="line">		INIT_WORK(&amp;xprt_work-&gt;work, xprt_open_worker);</span><br><span class="line">		queue_work(msm_ipc_router_workqueue, &amp;xprt_work-&gt;work);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		IPC_RTR_ERR(</span><br><span class="line">		<span class="string">"%s: malloc failure - Couldn't notify OPEN event"</span>,</span><br><span class="line">			__func__);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>添加一个端口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xprt_open_worker</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msm_ipc_router_xprt_work</span> *<span class="title">xprt_work</span> =</span></span><br><span class="line"><span class="class">		<span class="title">container_of</span>(<span class="title">work</span>, <span class="title">struct</span> <span class="title">msm_ipc_router_xprt_work</span>, <span class="title">work</span>);</span></span><br><span class="line"></span><br><span class="line">	msm_ipc_router_add_xprt(xprt_work-&gt;xprt);<span class="comment">//后续数据收发使用xprt_work-&gt;xprt</span></span><br><span class="line">	kfree(xprt_work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>创建读取任务</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;xprt_info-&gt;read_data, do_read_data);</span><br></pre></td></tr></table></figure>
<h2 id="接收modem数据"><a href="#接收modem数据" class="headerlink" title="接收modem数据"></a>接收modem数据</h2><p>modem有数据发给linux时，触发msm_ipc_router_smd_remote_notify</p>
<p>事件是SMD_EVENT_DATA</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SMD_EVENT_DATA:</span><br><span class="line">	<span class="keyword">if</span> (smd_read_avail(smd_xprtp-&gt;channel))</span><br><span class="line">		queue_delayed_work(smd_xprtp-&gt;smd_xprt_wq,</span><br><span class="line">				   &amp;smd_xprtp-&gt;read_work, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (smd_write_segment_avail(smd_xprtp-&gt;channel))</span><br><span class="line">		wake_up(&amp;smd_xprtp-&gt;write_avail_wait_q);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>其中md_xprtp-&gt;read_work在msm_ipc_router_smd_config_init里初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_DELAYED_WORK(&amp;smd_xprtp-&gt;read_work, smd_xprt_read_data);</span><br></pre></td></tr></table></figure>
<p><strong>smd_xprt_read_data</strong></p>
<ul>
<li><p>从modem侧读取数据包，放入队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">skb_queue_tail(smd_xprtp-&gt;in_pkt-&gt;pkt_fragment_q, ipc_rtr_pkt);</span><br><span class="line">msm_ipc_router_xprt_notify(&amp;smd_xprtp-&gt;xprt,</span><br><span class="line">                           IPC_ROUTER_XPRT_EVENT_DATA,</span><br><span class="line">                           (<span class="keyword">void</span> *)smd_xprtp-&gt;in_pkt);</span><br></pre></td></tr></table></figure>
<p>继续放入队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msm_ipc_router_xprt_notify</span><span class="params">(struct msm_ipc_router_xprt *xprt,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">unsigned</span> event,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pkt = clone_pkt((struct rr_packet *)data);</span><br><span class="line">	<span class="keyword">if</span> (!pkt)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;xprt_info-&gt;rx_lock_lhb2);</span><br><span class="line">	list_add_tail(&amp;pkt-&gt;<span class="built_in">list</span>, &amp;xprt_info-&gt;pkt_list);</span><br><span class="line">	__pm_stay_awake(&amp;xprt_info-&gt;ws);</span><br><span class="line">	mutex_unlock(&amp;xprt_info-&gt;rx_lock_lhb2);</span><br><span class="line">	queue_work(xprt_info-&gt;workqueue, &amp;xprt_info-&gt;read_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>唤醒读取任务，执行do_read_data</p>
<h3 id="处理modem的数据"><a href="#处理modem的数据" class="headerlink" title="处理modem的数据"></a>处理modem的数据</h3><p>do_read_data</p>
<p>modem发过来的数据包格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rr_header_v1</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> version;</span><br><span class="line">	<span class="keyword">uint32_t</span> type;</span><br><span class="line">	<span class="keyword">uint32_t</span> src_node_id;</span><br><span class="line">	<span class="keyword">uint32_t</span> src_port_id;</span><br><span class="line">	<span class="keyword">uint32_t</span> control_flag;</span><br><span class="line">	<span class="keyword">uint32_t</span> size;</span><br><span class="line">	<span class="keyword">uint32_t</span> dst_node_id;</span><br><span class="line">	<span class="keyword">uint32_t</span> dst_port_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>按照不同类型创建执行不同操作，其中控制消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hdr-&gt;type != IPC_ROUTER_CTRL_CMD_DATA) &#123;</span><br><span class="line">	process_control_msg(xprt_info, pkt);</span><br><span class="line">	<span class="keyword">goto</span> read_next_pkt1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中包含创建服务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (msg-&gt;cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> IPC_ROUTER_CTRL_CMD_HELLO:</span><br><span class="line">	rc = process_hello_msg(xprt_info, msg, hdr);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IPC_ROUTER_CTRL_CMD_RESUME_TX:</span><br><span class="line">	rc = process_resume_tx_msg(msg, pkt);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IPC_ROUTER_CTRL_CMD_NEW_SERVER: <span class="comment">//创建服务</span></span><br><span class="line">	rc = process_new_server_msg(xprt_info, msg, pkt);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IPC_ROUTER_CTRL_CMD_REMOVE_SERVER:</span><br><span class="line">	rc = process_rmv_server_msg(xprt_info, msg, pkt);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IPC_ROUTER_CTRL_CMD_REMOVE_CLIENT:</span><br><span class="line">	rc = process_rmv_client_msg(xprt_info, msg, pkt);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	rc = -ENOSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SMD"><a href="#SMD" class="headerlink" title="SMD"></a>SMD</h1><p>共享内存设备</p>
<p>partitions</p>
<p>smem_areas</p>
<h2 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h2><p>下表为支持了smd（共享内存设备）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">	SMEM_APPS,</span><br><span class="line">	SMEM_MODEM, //modem设备</span><br><span class="line">	SMEM_Q6,</span><br><span class="line">	SMEM_DSPS,</span><br><span class="line">	SMEM_WCNSS,</span><br><span class="line">	SMEM_MODEM_Q6_FW,</span><br><span class="line">	SMEM_RPM,</span><br><span class="line">	SMEM_TZ,</span><br><span class="line">	SMEM_SPSS,</span><br><span class="line">	SMEM_HYP,</span><br><span class="line">	NUM_SMEM_SUBSYSTEMS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>linux启动时会为其初始化，创建工作队列probe_work</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_SMD_SUBSYSTEMS; ++i) &#123;</span><br><span class="line">	remote_info[i].remote_pid = i;</span><br><span class="line">	remote_info[i].free_space = UINT_MAX;</span><br><span class="line">	INIT_WORK(&amp;remote_info[i].probe_work, smd_channel_probe_worker);</span><br><span class="line">	INIT_LIST_HEAD(&amp;remote_info[i].ch_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个远端设备有多个通道，默认支持64个通道</p>
<h2 id="创建SDM设备"><a href="#创建SDM设备" class="headerlink" title="创建SDM设备"></a>创建SDM设备</h2><p>modem启动后会向linux发消息，触发smd中断，linux侧执行smd_modem_irq_handler</p>
<p>smd_modem_irq_handler  —&gt;  handle_smd_irq  —&gt;  do_smd_probe</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_smd_probe</span><span class="params">(<span class="keyword">unsigned</span> remote_pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> free_space;</span><br><span class="line"></span><br><span class="line">	free_space = smem_get_free_space(remote_pid);</span><br><span class="line">	<span class="keyword">if</span> (free_space != remote_info[remote_pid].free_space) &#123;</span><br><span class="line">		remote_info[remote_pid].free_space = free_space;</span><br><span class="line">		schedule_work(&amp;remote_info[remote_pid].probe_work);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>远端设备（比如modem）通过共享内存区域传递数据到linux侧，如果有free_space有变化（细节暂不研究）则触发smd_channel_probe_worker</p>
<p>smd_channel_probe_worker  —&gt; smd_channel_probe_now  —&gt;    smd_alloc_channel</p>
<ul>
<li><p>从共享内存获取设备信息，得到设备名字（比如IPCRTR)</p>
</li>
<li><p>遍历所有通道 ，对未申请的通道进行申请</p>
</li>
<li><p>申请通道时会注册平台设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">smd_alloc_channel</span><span class="params">(struct smd_alloc_elm *alloc_elm, <span class="keyword">int</span> table_id,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct remote_proc_info *r_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* probe_worker guarentees ch-&gt;type will be a valid type */</span></span><br><span class="line">	<span class="keyword">if</span> (ch-&gt;type == SMD_APPS_MODEM) <span class="comment">//设备类型是SMD_APPS_MODEM</span></span><br><span class="line">		ch-&gt;notify_other_cpu = notify_modem_smd;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ch-&gt;type == SMD_APPS_QDSP)</span><br><span class="line">		ch-&gt;notify_other_cpu = notify_dsp_smd;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ch-&gt;type == SMD_APPS_DSPS)</span><br><span class="line">		ch-&gt;notify_other_cpu = notify_dsps_smd;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ch-&gt;type == SMD_APPS_WCNSS)</span><br><span class="line">		ch-&gt;notify_other_cpu = notify_wcnss_smd;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ch-&gt;type == SMD_APPS_Q6FW)</span><br><span class="line">		ch-&gt;notify_other_cpu = notify_modemfw_smd;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ch-&gt;type == SMD_APPS_RPM)</span><br><span class="line">		ch-&gt;notify_other_cpu = notify_rpm_smd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (smd_is_packet(alloc_elm)) &#123;</span><br><span class="line">        <span class="comment">//是包类型</span></span><br><span class="line">		ch-&gt;read = smd_packet_read;</span><br><span class="line">		ch-&gt;write = smd_packet_write;</span><br><span class="line">		ch-&gt;read_avail = smd_packet_read_avail;</span><br><span class="line">		ch-&gt;write_avail = smd_packet_write_avail;</span><br><span class="line">		ch-&gt;update_state = update_packet_state;</span><br><span class="line">		ch-&gt;read_from_cb = smd_packet_read_from_cb;</span><br><span class="line">		ch-&gt;is_pkt_ch = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ch-&gt;read = smd_stream_read;</span><br><span class="line">		ch-&gt;write = smd_stream_write;</span><br><span class="line">		ch-&gt;read_avail = smd_stream_read_avail;</span><br><span class="line">		ch-&gt;write_avail = smd_stream_write_avail;</span><br><span class="line">		ch-&gt;update_state = update_stream_state;</span><br><span class="line">		ch-&gt;read_from_cb = smd_stream_read;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_word_access_ch(ch-&gt;type)) &#123;</span><br><span class="line">		ch-&gt;read_from_fifo = smd_memcpy32_from_fifo;</span><br><span class="line">		ch-&gt;write_to_fifo = smd_memcpy32_to_fifo;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ch-&gt;read_from_fifo = smd_memcpy_from_fifo;</span><br><span class="line">		ch-&gt;write_to_fifo = smd_memcpy_to_fifo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	smd_memcpy_from_fifo(ch-&gt;name, alloc_elm-&gt;name, SMD_MAX_CH_NAME_LEN);</span><br><span class="line">	ch-&gt;name[SMD_MAX_CH_NAME_LEN<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ch-&gt;pdev.name = ch-&gt;name;</span><br><span class="line">	ch-&gt;pdev.id = ch-&gt;type;</span><br><span class="line"></span><br><span class="line">	SMD_INFO(<span class="string">"smd_alloc_channel() '%s' cid=%d\n"</span>,</span><br><span class="line">		 ch-&gt;name, ch-&gt;n);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;smd_creation_mutex);</span><br><span class="line">	list_add(&amp;ch-&gt;ch_list, &amp;smd_ch_closed_list);</span><br><span class="line">	mutex_unlock(&amp;smd_creation_mutex);</span><br><span class="line"></span><br><span class="line">	platform_device_register(&amp;ch-&gt;pdev);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>启动时会为modem创建多个通道，比如</p>
<p>IPCRTR：用于QMI数据收发</p>
<p>DATA40_CNTL：qti进程使用这个通道，对应的设备名字smdcntl8（在设备树中定义）</p>
<h2 id="smdcntl设备"><a href="#smdcntl设备" class="headerlink" title="smdcntl设备"></a>smdcntl设备</h2><p>设备树中包含了smdpkt设备，linux启动时执行msm_smd_pkt_probe   —&gt;  smd_pkt_devicetree_init</p>
<p>smd_pkt_devicetree_init查询设备树中smdpkt的配置，创建字符设备，操作函数为smd_pkt_fops</p>
<h3 id="打开设备"><a href="#打开设备" class="headerlink" title="打开设备"></a>打开设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int smd_pkt_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">	//为SMD平台设备(比如DATA40_CNTL)添加平台驱动</span><br><span class="line">	r = smd_pkt_add_driver(smd_pkt_devp);</span><br><span class="line">	if (smd_pkt_devp-&gt;ch == 0) &#123;</span><br><span class="line">	//打开SMD通道</span><br><span class="line">		r = smd_named_open_on_edge(smd_pkt_devp-&gt;ch_name,</span><br><span class="line">					   smd_pkt_devp-&gt;edge,</span><br><span class="line">					   &amp;smd_pkt_devp-&gt;ch,</span><br><span class="line">					   smd_pkt_devp,</span><br><span class="line">					   ch_notify);//远端有数据发给linux时，调用ch_notify</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><p>数据直接写入对应的smd通道里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> smd_pkt_write(struct file *file,</span><br><span class="line">		       <span class="keyword">const</span> <span class="keyword">char</span> __user *_buf,</span><br><span class="line">		       <span class="keyword">size_t</span> count,</span><br><span class="line">		       <span class="keyword">loff_t</span> *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">	r = smd_write_start(smd_pkt_devp-&gt;ch, count);</span><br><span class="line">    ...</span><br><span class="line">    r = smd_write_segment(smd_pkt_devp-&gt;ch,</span><br><span class="line">                          (<span class="keyword">void</span> *)(buf + bytes_written),</span><br><span class="line">                          (count - bytes_written));</span><br></pre></td></tr></table></figure>
<h3 id="读取数据-1"><a href="#读取数据-1" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> smd_pkt_read(struct file *file,</span><br><span class="line">		       <span class="keyword">char</span> __user *_buf,</span><br><span class="line">		       <span class="keyword">size_t</span> count,</span><br><span class="line">		       <span class="keyword">loff_t</span> *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待数据</span></span><br><span class="line">	r = wait_event_interruptible(smd_pkt_devp-&gt;ch_read_wait_queue,</span><br><span class="line">				     !smd_pkt_devp-&gt;ch ||</span><br><span class="line">				     (smd_cur_packet_size(smd_pkt_devp-&gt;ch) &gt; <span class="number">0</span></span><br><span class="line">				      &amp;&amp; smd_read_avail(smd_pkt_devp-&gt;ch)) ||</span><br><span class="line">				     smd_pkt_devp-&gt;has_reset);</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">	pkt_size = smd_cur_packet_size(smd_pkt_devp-&gt;ch);</span><br><span class="line">    </span><br><span class="line">    r = smd_read(smd_pkt_devp-&gt;ch,</span><br><span class="line">                 (buf + bytes_read),</span><br><span class="line">                 (pkt_size - bytes_read));</span><br></pre></td></tr></table></figure>
<p>打开时通道时注册了回调ch_notify</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ch_notify</span><span class="params">(<span class="keyword">void</span> *priv, <span class="keyword">unsigned</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (event) &#123;</span><br><span class="line">	<span class="keyword">case</span> SMD_EVENT_DATA: &#123;</span><br><span class="line">		check_and_wakeup_reader(smd_pkt_devp);<span class="comment">//唤醒读取等待进程</span></span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/mdm9x07/">mdm9x07</a><a href="/tags/rmmnet/">rmmnet</a><a href="/tags/QMI/">QMI</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/Linux系统/linux USB host 驱动/" class="next">linux USB host驱动</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rmnet-USB网口"><span class="toc-text">rmnet USB网口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设置接口"><span class="toc-text">设置接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#控制通道连接初始化"><span class="toc-text">控制通道连接初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据通道连接初始化"><span class="toc-text">数据通道连接初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通讯"><span class="toc-text">通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#host向device发命令"><span class="toc-text">host向device发命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#device向host发命令"><span class="toc-text">device向host发命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#host向device发数据"><span class="toc-text">host向device发数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#device向host发数据"><span class="toc-text">device向host发数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BAM数据收发"><span class="toc-text">BAM数据收发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#发送数据"><span class="toc-text">发送数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接收数据"><span class="toc-text">接收数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#modem-网口"><span class="toc-text">modem 网口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#网口创建"><span class="toc-text">网口创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打开网口"><span class="toc-text">打开网口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送数据-1"><span class="toc-text">发送数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接收数据-1"><span class="toc-text">接收数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#qti数据处理"><span class="toc-text">qti数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#qti接收host端数据"><span class="toc-text">qti接收host端数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qti接收modem数据"><span class="toc-text">qti接收modem数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打开通信通道"><span class="toc-text">打开通信通道</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#qmuxd进程"><span class="toc-text">qmuxd进程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#qmi客户端"><span class="toc-text">qmi客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化-1"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送数据-2"><span class="toc-text">发送数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读取数据"><span class="toc-text">读取数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipc-router"><span class="toc-text">ipc router</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化-2"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加诊断服务"><span class="toc-text">添加诊断服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QMI服务注册"><span class="toc-text">QMI服务注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipc-route-smd"><span class="toc-text">ipc route smd</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化-3"><span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QMI数据收发"><span class="toc-text">QMI数据收发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发送数据-3"><span class="toc-text">发送数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接收数据-2"><span class="toc-text">接收数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加密认证"><span class="toc-text">加密认证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#irsc-util"><span class="toc-text">irsc_util</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Modem发数据到Linux"><span class="toc-text">Modem发数据到Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#modem侧打开端口"><span class="toc-text">modem侧打开端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接收modem数据"><span class="toc-text">接收modem数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#处理modem的数据"><span class="toc-text">处理modem的数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SMD"><span class="toc-text">SMD</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化-4"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建SDM设备"><span class="toc-text">创建SDM设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#smdcntl设备"><span class="toc-text">smdcntl设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#打开设备"><span class="toc-text">打开设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写数据"><span class="toc-text">写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取数据-1"><span class="toc-text">读取数据</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/芯片方案/mdm9x07/QMI 拨号&网口/">QMI 拨号&网口</a></li><li class="post-list-item"><a class="post-list-link" href="/Linux系统/linux USB host 驱动/">linux USB host驱动</a></li><li class="post-list-item"><a class="post-list-link" href="/Linux系统/linux USB gadget 驱动/">linux gadget 驱动</a></li><li class="post-list-item"><a class="post-list-link" href="/Linux系统/cmdline初始流程/">cmdline初始流程</a></li><li class="post-list-item"><a class="post-list-link" href="/Linux系统/linux根文件系统挂载过程/">linux根文件系统挂载过程</a></li><li class="post-list-item"><a class="post-list-link" href="/芯片方案/mdm9x07/mdm9x07内存使用分析/">mdm9x07内存使用分析</a></li><li class="post-list-item"><a class="post-list-link" href="/allegro/allegro/">allegro/allegro</a></li><li class="post-list-item"><a class="post-list-link" href="/深度学习/TensorFlow笔记/">TensorFlow笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/深度学习/MTCNN tensorflow实现/">MTCNN tensorflow实现</a></li><li class="post-list-item"><a class="post-list-link" href="/深度学习/Caffe笔记/">Caffe笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ARM架构/">ARM架构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux内核/">linux内核</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/uboot/">uboot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/深度学习/">深度学习</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/芯片方案/">芯片方案</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/中断/" style="font-size: 15px;">中断</a> <a href="/tags/cmdline/" style="font-size: 15px;">cmdline</a> <a href="/tags/USB/" style="font-size: 15px;">USB</a> <a href="/tags/rootfs/" style="font-size: 15px;">rootfs</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/caffe2/" style="font-size: 15px;">caffe2</a> <a href="/tags/MTCNN/" style="font-size: 15px;">MTCNN</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/arm/" style="font-size: 15px;">arm</a> <a href="/tags/uboot/" style="font-size: 15px;">uboot</a> <a href="/tags/linux驱动/" style="font-size: 15px;">linux驱动</a> <a href="/tags/串口/" style="font-size: 15px;">串口</a> <a href="/tags/tty/" style="font-size: 15px;">tty</a> <a href="/tags/TensorFlow/" style="font-size: 15px;">TensorFlow</a> <a href="/tags/环境搭建/" style="font-size: 15px;">环境搭建</a> <a href="/tags/芯片资料/" style="font-size: 15px;">芯片资料</a> <a href="/tags/mdm9x07/" style="font-size: 15px;">mdm9x07</a> <a href="/tags/imx6/" style="font-size: 15px;">imx6</a> <a href="/tags/rmmnet/" style="font-size: 15px;">rmmnet</a> <a href="/tags/QMI/" style="font-size: 15px;">QMI</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">wzhchen.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>