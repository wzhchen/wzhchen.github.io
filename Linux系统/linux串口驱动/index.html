<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="嵌入式开发"><title>linux串口驱动 | wzhchen's blog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">linux串口驱动</h1><a id="logo" href="/.">wzhchen's blog</a><p class="description">学习、记录、分享</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">linux串口驱动</h1><div class="post-meta"><a href="/Linux系统/linux串口驱动/#comments" class="comment-count"></a><p><span class="date">Mar 22, 2018</span><span><a href="/categories/linux内核/" class="category">linux内核</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>工作中需要调试linux系统下的串口驱动，因特殊需求需要创建一些虚拟串口，工作中需要将串口驱动的整个流程全部梳理，中途中遇到了不少问题，现在问题已经基本解决，现将整个过程做个总结记录。</p>
<a id="more"></a>
<h1 id="整体框图"><a href="#整体框图" class="headerlink" title="整体框图"></a>整体框图</h1><p>首先给出整体框图，后面结合代码详细介绍各个流程</p>
<img src="/Linux系统/linux串口驱动/uart_all.png">
<h1 id="UART驱动注册"><a href="#UART驱动注册" class="headerlink" title="UART驱动注册"></a>UART驱动注册</h1><h2 id="uart-driver数据结构"><a href="#uart-driver数据结构" class="headerlink" title="uart_driver数据结构"></a>uart_driver数据结构</h2><p>向kernel中注册一个串口驱动之前，需要先准备一个uart_driver结构该，uart_driver就是串口的驱动</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 虚拟uart驱动 结构体*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> <span class="title">virtual_uart_driver</span> = &#123;</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.driver_name = <span class="string">"virtual_serial"</span>,</span><br><span class="line">	.dev_name = <span class="string">"COM"</span>,</span><br><span class="line">	.nr = VIRTUAL_UART_PORT_NR,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>driver_name：串口驱动的名字，可以自定义<br>dev_name：使用该驱动注册串口设备的设备名前缀，也可以自定义<br>nr：该驱动允许注册的设备数量，尽可能按照实际需求来写，<em>注册串口驱动时会根据nr来申请资源</em></p>
<h2 id="uart-register-driver注册驱动"><a href="#uart-register-driver注册驱动" class="headerlink" title="uart_register_driver注册驱动"></a>uart_register_driver注册驱动</h2><p>准备好uart_driver数据结构后，调用uart_register_driver即可将其注册进kernel.</p>
<p>接下来看看uart_register_driver里做了哪些事情（<em>请注意nr的使用</em>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为uart_driver-&gt;state, 每个端口需要一个state</span></span><br><span class="line">drv-&gt;state = kzalloc(<span class="keyword">sizeof</span>(struct uart_state) * drv-&gt;nr, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!drv-&gt;state)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line"><span class="comment">//创建一个tty_driver数据结构，并为各个端口分配资源</span></span><br><span class="line">normal = alloc_tty_driver(drv-&gt;nr);</span><br><span class="line"><span class="keyword">if</span> (!normal)</span><br><span class="line">	<span class="keyword">goto</span> out_kfree;</span><br><span class="line"><span class="comment">//uart_driver中的tty_driver指向新创建的tty_driver，方便其他代码根据uart_driver查找tty_driver </span></span><br><span class="line">drv-&gt;tty_driver = normal;</span><br><span class="line"><span class="comment">//一系统的参数初始化</span></span><br><span class="line">normal-&gt;driver_name	= drv-&gt;driver_name;</span><br><span class="line">normal-&gt;name		= drv-&gt;dev_name;</span><br><span class="line">normal-&gt;major		= drv-&gt;major;</span><br><span class="line">normal-&gt;minor_start	= drv-&gt;minor;</span><br><span class="line">normal-&gt;type		= TTY_DRIVER_TYPE_SERIAL;</span><br><span class="line">normal-&gt;subtype		= SERIAL_TYPE_NORMAL;</span><br><span class="line">normal-&gt;init_termios	= tty_std_termios;</span><br><span class="line">normal-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class="line">normal-&gt;init_termios.c_ispeed = normal-&gt;init_termios.c_ospeed = <span class="number">9600</span>;</span><br><span class="line">normal-&gt;flags		= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;</span><br><span class="line">normal-&gt;driver_state    = drv;</span><br><span class="line"><span class="comment">//设置tty_driver的ops，uart_ops由kernel核心代码提供</span></span><br><span class="line">tty_set_operations(normal, &amp;uart_ops);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialise the UART state(s).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; drv-&gt;nr; i++) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> = <span class="title">drv</span>-&gt;<span class="title">state</span> + <span class="title">i</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span> = &amp;<span class="title">state</span>-&gt;<span class="title">port</span>;</span></span><br><span class="line">	<span class="comment">//初始化每个tty端口，核心部分是tty_buffer_init</span></span><br><span class="line">	tty_port_init(port);</span><br><span class="line">	port-&gt;ops = &amp;uart_port_ops;</span><br><span class="line">	port-&gt;close_delay     = HZ / <span class="number">2</span>;	<span class="comment">/* .5 seconds */</span></span><br><span class="line">	port-&gt;closing_wait    = <span class="number">30</span> * HZ;<span class="comment">/* 30 seconds */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册tty_driver</span></span><br><span class="line">retval = tty_register_driver(normal);</span><br><span class="line"><span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br></pre></td></tr></table></figure>
<h2 id="uart-port数据结构"><a href="#uart-port数据结构" class="headerlink" title="uart_port数据结构"></a>uart_port数据结构</h2><p>向kernel中添加串口之前，需要准备好uart_port数据结构</p>
<p>uart_port与底层的硬件密切相关，对于驱动框架而言，最重要的是uart_ops，定义了操作硬件的接口</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> <span class="title">virtual_uart_pops</span> = &#123;</span></span><br><span class="line">	.tx_empty = virtual_tx_empty,</span><br><span class="line">	.set_mctrl = virtual_set_mctrl,</span><br><span class="line">	.get_mctrl = virtual_get_mctrl,</span><br><span class="line">	.stop_tx = virtual_nothing,</span><br><span class="line">	.start_tx = virtual_start_tx,</span><br><span class="line">	.stop_rx = virtual_nothing,</span><br><span class="line">	.break_ctl = virtual_break_ctl,</span><br><span class="line">	.startup = virtual_startup,</span><br><span class="line">	.shutdown = virtual_nothing,</span><br><span class="line">	.set_termios = virtual_set_termios,</span><br><span class="line">	.type = virtual_type,</span><br><span class="line">	.release_port = virtual_nothing,</span><br><span class="line">	.request_port = virtual_nothing1,</span><br><span class="line">	.config_port = virtual_config_port,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外1个重要成员是line，指示该uart_port属于驱动中的第几个端口，对于到应用层的串口编号</p>
<h2 id="uart-add-one-port-添加串口"><a href="#uart-add-one-port-添加串口" class="headerlink" title="uart_add_one_port 添加串口"></a>uart_add_one_port 添加串口</h2><p>uart_driver注册好后，需要将uart_port添加进去</p>
<blockquote>
<p><em>uart_driver只是一框架，不具备与硬件打交道的能力，与硬件打交道是uart_port，因此一般调试驱动时更多的是在修改uart_port，但查找问题的过程一般要贯穿整个流程</em></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; VIRTUAL_UART_PORT_NR; i++) &#123;</span><br><span class="line">	virtual_uart_port[i].ops = &amp;virtual_uart_pops;</span><br><span class="line">	virtual_uart_port[i].attr_group = &amp;virtual_attr_group;</span><br><span class="line">	virtual_uart_port[i].type = PORT_VIRTUAL;</span><br><span class="line">	virtual_uart_port[i].line = i;</span><br><span class="line">	<span class="comment">//将准备好的uart_port添加到uart_driver中</span></span><br><span class="line">	ret = uart_add_one_port(&amp;virtual_uart_driver, virtual_uart_port+i);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">		<span class="keyword">goto</span> remove_port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来看看uart_add_one_port干了些什么事（<em>以下只将重要部分展现出来</em>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uart_add_one_port</span><span class="params">(struct uart_driver *drv, struct uart_port *uport)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">tty_dev</span>;</span></span><br><span class="line">	state = drv-&gt;state + uport-&gt;line;</span><br><span class="line">	port = &amp;state-&gt;port;</span><br><span class="line">	state-&gt;uart_port = uport;</span><br><span class="line">	uport-&gt;state = state;</span><br><span class="line">  	<span class="comment">//使用serial_core提供的代码对端口进行配置，会调用uart_port的ops里的接口对硬件做配置</span></span><br><span class="line">	uart_configure_port(drv, state, uport);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Register the port whether it's detected or not.  This allows</span></span><br><span class="line"><span class="comment">	 * setserial to be used to alter this port's parameters.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tty_dev = tty_port_register_device_attr(port, drv-&gt;tty_driver,</span><br><span class="line">			uport-&gt;line, uport-&gt;dev, port, uport-&gt;tty_groups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来跟踪一下tty_port_register_device_attr</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device *<span class="title">tty_port_register_device_attr</span><span class="params">(struct tty_port *port,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct tty_driver *driver, <span class="keyword">unsigned</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct device *device, <span class="keyword">void</span> *drvdata,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> struct attribute_group **attr_grp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//tty_port_link_devie非常简单，将tty_driver的uart_port指向当前的port</span></span><br><span class="line">	<span class="comment">//    driver-&gt;ports[index] = port;</span></span><br><span class="line">	tty_port_link_device(port, driver, index);</span><br><span class="line">	<span class="keyword">return</span> tty_register_device_attr(driver, index, device, drvdata,</span><br><span class="line">			attr_grp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟踪tty_register_device_attr（<em>以下只将重要部分展现出来</em>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device *<span class="title">tty_register_device_attr</span><span class="params">(struct tty_driver *driver,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">unsigned</span> index, struct device *device,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">void</span> *drvdata,</span></span></span><br><span class="line"><span class="function"><span class="params">				   <span class="keyword">const</span> struct attribute_group **attr_grp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">dev_t</span> devt = MKDEV(driver-&gt;major, driver-&gt;minor_start) + index;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;type == TTY_DRIVER_TYPE_PTY)</span><br><span class="line">		pty_line_name(driver, index, name);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tty_line_name(driver, index, name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_ALLOC)) &#123;</span><br><span class="line">      <span class="comment">//初始化字符设备tty_driver-&gt;cdev,并添加进kernel，文件操作使用tty_fops</span></span><br><span class="line">		retval = tty_cdev_add(driver, devt, index, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</span><br><span class="line">	dev-&gt;devt = devt;</span><br><span class="line">	dev_set_name(dev, <span class="string">"%s"</span>, name);</span><br><span class="line"></span><br><span class="line">	retval = device_register(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="各数据结构的关系"><a href="#各数据结构的关系" class="headerlink" title="各数据结构的关系"></a>各数据结构的关系</h2><p>经过一系列的注册及初始化过程后，可以得到以下关系图</p>
<img src="/Linux系统/linux串口驱动/uart注册.png">
<h1 id="open-uart，打开串口"><a href="#open-uart，打开串口" class="headerlink" title="open uart，打开串口"></a>open uart，打开串口</h1><p>应用层打开串口通常是通过打开/dev/下的节点来实现，应用层打开串口后就可以像操作普通文件一样来操作串口了，下面详细讲述一下open串口的具体流程</p>
<p>##　tty_open</p>
<p>首先根据VFS可以查找到tty_fops，因此打开/dev/COMx时会调用tty_open，tty_open会做许多初始化</p>
<ul>
<li>申请一个tty_struct，每个串口只有1个tty_struct，如果多个应用打开同一个串口时，不会申请新的，直接使用已经申请好的；</li>
<li>将tty_struct与当前的文件描述符进行绑定（关闭串口时会用到，如果还有其它文件描述符占用tty_struct，关闭串口时则不会释放tty_struct，否则会释放）；</li>
<li>调用tty_struct-&gt;ops-&gt;open打开tty，做进一步的打开操作（<em>向下一层进攻，开始研究tty_struct的申请过程</em>）</li>
<li>其实对串口本身不相关的初始化</li>
</ul>
<h2 id="申请tty-struct"><a href="#申请tty-struct" class="headerlink" title="申请tty_struct"></a>申请tty_struct</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tty_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">	<span class="keyword">dev_t</span> device = inode-&gt;i_rdev;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//根据device（有设备号）可以查找刚才注册的tty_driver，同时也可以得到index（第几个串口）</span></span><br><span class="line">		driver = tty_lookup_driver(device, filp, &amp;noctty, &amp;index);</span><br><span class="line">	<span class="comment">//在tty_driver中取出第index个tty_struct指针，没有别的应用打开该串口时，则返回的是一个空指针</span></span><br><span class="line">		<span class="comment">/* check whether we're reopening an existing tty */</span></span><br><span class="line">		tty = tty_driver_lookup_tty(driver, inode, index);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(tty)) &#123;</span><br><span class="line">			retval = PTR_ERR(tty);</span><br><span class="line">			<span class="keyword">goto</span> err_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tty) &#123;</span><br><span class="line">	<span class="comment">//如果有别的应用打开了这个串口，则只需要将计数加1</span></span><br><span class="line">		tty_lock(tty);</span><br><span class="line">		retval = tty_reopen(tty);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			tty_unlock(tty);</span><br><span class="line">			tty = ERR_PTR(retval);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span>	<span class="comment">/* Returns with the tty_lock held for now */</span></span><br><span class="line">		tty = tty_init_dev(driver, index); <span class="comment">//如果没有别的应用打开这个串口，需要自己创建tty_struct</span></span><br></pre></td></tr></table></figure>
<p>进一步来看tty_init_dev（<em>以下只将重要部分展现出来</em>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tty_struct *<span class="title">tty_init_dev</span><span class="params">(struct tty_driver *driver, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="comment">//重点是通过alloc_tty_strcut来申请1个tty_struct</span></span><br><span class="line">	tty = alloc_tty_struct(driver, idx);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//将tty_driver中的tty_struct指向新申请的tty_struct，便于其他应用直接使用</span></span><br><span class="line">  	<span class="comment">//初始化tty_struct的termios</span></span><br><span class="line">	retval = tty_driver_install_tty(driver, tty);</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//初始化tty_sturct-&gt;tty_port</span></span><br><span class="line">	<span class="keyword">if</span> (!tty-&gt;port)</span><br><span class="line">		tty-&gt;port = driver-&gt;ports[idx];</span><br><span class="line">	tty-&gt;port-&gt;itty = tty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这也是一个重要的东西</span></span><br><span class="line">	retval = tty_ldisc_setup(tty, tty-&gt;link);</span><br><span class="line">	<span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看alloc_tty_struct，就是一系统的初始化（<em>以下只将重要部分展现出来</em>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tty_struct *<span class="title">alloc_tty_struct</span><span class="params">(struct tty_driver *driver, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">	tty = kzalloc(<span class="keyword">sizeof</span>(*tty), GFP_KERNEL);</span><br><span class="line">	tty-&gt;magic = TTY_MAGIC;</span><br><span class="line">  	<span class="comment">//这是一个重要的地方，使用N_TYY作为tty的ldisc，简化成tty-&gt;ldisc-&gt;ops = tty_ldisc_N_TTY</span></span><br><span class="line">	tty_ldisc_init(tty);</span><br><span class="line">	tty-&gt;driver = driver;</span><br><span class="line">  	<span class="comment">//tty_struct的ops直接使用tty_driver的ops，对于串口就是uart_ops</span></span><br><span class="line">	tty-&gt;ops = driver-&gt;ops;</span><br><span class="line">	tty-&gt;index = idx;</span><br><span class="line">	tty_line_name(driver, idx, tty-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="n-tty"><a href="#n-tty" class="headerlink" title="n_tty"></a>n_tty</h2><p><strong>注意：tty的数据读取主要由tty_ldisc_N_TTY来完成</strong></p>
<p>n_tty负责tty的读写控制，各种数据缓存、阻塞、调度处理等<br>另外也要处理tty的字符转换，比如回显、换行转回车等</p>
<p>在申请tty_struct时调用了tty_ldisc_setup，现在来看看tty_ldisc_setup（<em>以下只将重要部分展现出来</em>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tty_ldisc_setup</span><span class="params">(struct tty_struct *tty, struct tty_struct *o_tty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span> = <span class="title">tty</span>-&gt;<span class="title">ldisc</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="comment">//使用tty_ldisc_N_TTY-&gt;open打开，即执行n_tty_open</span></span><br><span class="line">	retval = tty_ldisc_open(tty, ld);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>n_tty_open会初始化处理数据需要的各类数据结构，本次工作没有对n_tty做深入研究，因此不作进一步展开</p>
<h2 id="uart-open"><a href="#uart-open" class="headerlink" title="uart_open"></a>uart_open</h2><p>打开串口的最后一重要部分就是执行uart_open，uart_open由serial_core.c提供，完成串口的初始操作</p>
<p>来看下uart_open干了哪些事（<em>同样只将重要部分展现出来</em>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uart_open</span><span class="params">(struct tty_struct *tty, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> *<span class="title">drv</span> = (<span class="title">struct</span> <span class="title">uart_driver</span> *)<span class="title">tty</span>-&gt;<span class="title">driver</span>-&gt;<span class="title">driver_state</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval, line = tty-&gt;index;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> = <span class="title">drv</span>-&gt;<span class="title">state</span> + <span class="title">line</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span> = &amp;<span class="title">state</span>-&gt;<span class="title">port</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开计算，关闭时会用到</span></span><br><span class="line">	port-&gt;count++;</span><br><span class="line"></span><br><span class="line">	tty-&gt;driver_data = state;</span><br><span class="line">	state-&gt;uart_port-&gt;state = state;</span><br><span class="line">    tty_port_tty_set(port, tty);<span class="comment">//port-&gt;tty = tty</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//做进一步处理</span></span><br><span class="line">	retval = uart_startup(tty, state, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>uart_open没干什么事情，都丢给了uart_startup来处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uart_startup</span><span class="params">(struct tty_struct *tty, struct uart_state *state,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> init_hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span> = &amp;<span class="title">state</span>-&gt;<span class="title">port</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果已经初始过，则直接退出</span></span><br><span class="line">	<span class="keyword">if</span> (port-&gt;flags &amp; ASYNC_INITIALIZED)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	uart_port_startup(tty, state, init_hw);</span><br><span class="line">    <span class="comment">//标记已经成功初始化</span></span><br><span class="line">	set_bit(ASYNCB_INITIALIZED, &amp;port-&gt;flags);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过uart_startup也没干什么事，又丢给了uart_port_startup处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uart_port_startup</span><span class="params">(struct tty_struct *tty, struct uart_state *state,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> init_hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">uport</span> = <span class="title">state</span>-&gt;<span class="title">uart_port</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> page;</span><br><span class="line">	<span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uport-&gt;type == PORT_UNKNOWN)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为发送申请4Kbytes的FIFO</span></span><br><span class="line">	<span class="keyword">if</span> (!state-&gt;xmit.buf) &#123;</span><br><span class="line">		<span class="comment">/* This is protected by the per port mutex */</span></span><br><span class="line">		page = get_zeroed_page(GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		state-&gt;xmit.buf = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) page;</span><br><span class="line">		uart_circ_clear(&amp;state-&gt;xmit);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调用最底层的硬件startup来初始化硬件</span></span><br><span class="line">	retval = uport-&gt;ops-&gt;startup(uport);</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (uart_console(uport) &amp;&amp; uport-&gt;cons-&gt;cflag) &#123;</span><br><span class="line">			tty-&gt;termios.c_cflag = uport-&gt;cons-&gt;cflag;</span><br><span class="line">			uport-&gt;cons-&gt;cflag = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//打开串口时会配置默认波特率，需要特别注意</span></span><br><span class="line">		uart_change_speed(tty, state, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析到这里，就已经从应用层打开串口到底层硬件初始的所有流程，此时底层硬件的startup需要根据实际硬件来编写，此次工作中是一种特殊的虚拟串口驱动，因此startup会相对比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">virtual_startup</span><span class="params">(struct uart_port *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">phy_port</span>;</span></span><br><span class="line">	<span class="comment">//获取虚拟串口绑定的硬件串口，将硬件串口的波特率等信息复制到虚拟串口</span></span><br><span class="line">	phy_port = get_phy_uart_by_config(port-&gt;line);</span><br><span class="line">	<span class="keyword">if</span>(phy_port) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">vir_tty</span> = <span class="title">port</span>-&gt;<span class="title">state</span>-&gt;<span class="title">port</span>.<span class="title">tty</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">phy_tty</span> = <span class="title">phy_port</span>-&gt;<span class="title">state</span>-&gt;<span class="title">port</span>.<span class="title">tty</span>;</span></span><br><span class="line"></span><br><span class="line">		vir_tty-&gt;termios.c_cflag = phy_tty-&gt;termios.c_cflag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="各数据结构的关系-1"><a href="#各数据结构的关系-1" class="headerlink" title="各数据结构的关系"></a>各数据结构的关系</h2><p>经过一系统初始后，可以得到以下关系图</p>
<img src="/Linux系统/linux串口驱动/uart_open.png">
<h1 id="write-uart，串口写流程"><a href="#write-uart，串口写流程" class="headerlink" title="write uart，串口写流程"></a>write uart，串口写流程</h1><p>向串口中写数据分成几个层次,每一层都分工明确</p>
<p>tty_write<br>​    do_tty_write<br>​        n_tty_write<br>​            uart_write/uart_put_char<br>​                底层硬件驱动_start_tx<br>​                    handle_tx</p>
<h2 id="tty-write"><a href="#tty-write" class="headerlink" title="tty_write"></a>tty_write</h2><p>功能相对比较简,tty_write调用do_tty_write</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> ssize_t <span class="title">do_tty_write</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">ssize_t</span> (*write)(struct tty_struct *, struct file *, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">	struct tty_struct *tty,</span></span></span><br><span class="line"><span class="function"><span class="params">	struct file *file,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">ssize_t</span> ret, written = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> chunk;</span><br><span class="line"></span><br><span class="line">	chunk = <span class="number">2048</span>;</span><br><span class="line">	<span class="keyword">if</span> (test_bit(TTY_NO_WRITE_SPLIT, &amp;tty-&gt;flags))</span><br><span class="line">		chunk = <span class="number">65536</span>;</span><br><span class="line">	<span class="keyword">if</span> (count &lt; chunk)</span><br><span class="line">		chunk = count;</span><br><span class="line">	<span class="comment">//为tty_struct-&gt;write_buf准备一段空间,有一点小小算法在效率和内存占用上取一个平衡</span></span><br><span class="line">	<span class="comment">/* write_buf/write_cnt is protected by the atomic_write_lock mutex */</span></span><br><span class="line">	<span class="keyword">if</span> (tty-&gt;write_cnt &lt; chunk) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf_chunk;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (chunk &lt; <span class="number">1024</span>)</span><br><span class="line">			chunk = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">		buf_chunk = kmalloc(chunk, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!buf_chunk) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		kfree(tty-&gt;write_buf);</span><br><span class="line">		tty-&gt;write_cnt = chunk;</span><br><span class="line">		tty-&gt;write_buf = buf_chunk;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//循环将数据从用户态复制到write_buf中,然后调用n_tty_write发送</span></span><br><span class="line">	<span class="comment">/* Do the write .. */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> size = count;</span><br><span class="line">		<span class="keyword">if</span> (size &gt; chunk)</span><br><span class="line">			size = chunk;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(tty-&gt;write_buf, buf, size))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		ret = write(tty, file, tty-&gt;write_buf, size);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		written += ret;</span><br><span class="line">		buf += ret;</span><br><span class="line">		count -= ret;</span><br><span class="line">		<span class="keyword">if</span> (!count)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//每写完一次调度一次,因为n_tty_write只是将数据写入缓存</span></span><br><span class="line">		<span class="comment">//底层硬件发送一般比较慢,调度一次可以更加充分的利用CPU</span></span><br><span class="line">		ret = -ERESTARTSYS;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		cond_resched();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do_tty_write,将数据分次发给n_tty_write,n_tty_write会做更加复杂的处理,因为linux将tty数据收发的主要工作交给了n_tty</p>
<p>##n_tty_write_</p>
<p>n_tty_write的代码比较多,这里就不贴出来了,描述一下它的几种重要流程</p>
<ul>
<li>处理tty的回显</li>
<li>通过tty_write_room(用调用uart_write_room)获取底层xmit.buf可用空间</li>
<li>调用uart_write将数据写入串口的xmit.buf中</li>
<li>如果底层xmit.buf的空间不足导致数据没有发送完,则将当前进程挂起,等待唤醒,由tty-&gt;write_wait控制</li>
</ul>
<h2 id="uart-write"><a href="#uart-write" class="headerlink" title="uart_write"></a>uart_write</h2><p>uart_write负责将数据写入xmit.buf,然后调用uart_start启动底层发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static int uart_write(struct tty_struct *tty,</span><br><span class="line">					const unsigned char *buf, int count)</span><br><span class="line">&#123;</span><br><span class="line">	struct uart_state *state = tty-&gt;driver_data;</span><br><span class="line">	struct uart_port *port;</span><br><span class="line">	struct circ_buf *circ;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	int c, ret = 0;</span><br><span class="line"></span><br><span class="line">	port = state-&gt;uart_port;</span><br><span class="line">	circ = &amp;state-&gt;xmit;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;port-&gt;lock, flags);</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		c = CIRC_SPACE_TO_END(circ-&gt;head, circ-&gt;tail, UART_XMIT_SIZE);</span><br><span class="line">		if (count &lt; c)</span><br><span class="line">			c = count;</span><br><span class="line">		//如果circ中没有可用空间了则退出,底层中断会不停的中取走数据</span><br><span class="line">		if (c &lt;= 0)</span><br><span class="line">			break;</span><br><span class="line">		memcpy(circ-&gt;buf + circ-&gt;head, buf, c);</span><br><span class="line">		circ-&gt;head = (circ-&gt;head + c) &amp; (UART_XMIT_SIZE - 1);</span><br><span class="line">		buf += c;</span><br><span class="line">		count -= c;</span><br><span class="line">		ret += c;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irqrestore(&amp;port-&gt;lock, flags);</span><br><span class="line">	//通知底层,可以执行发送动作</span><br><span class="line">	uart_start(tty);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="uart-start"><a href="#uart-start" class="headerlink" title="uart_start"></a>uart_start</h2><p>uart_start简单的调用底层驱动的start_tx</p>
<p>底层驱动的start_tx一般只是打开发送中断（<em>芯片tx fifo中没有数据则产生中断,数据发完后再关闭中断</em>）</p>
<h2 id="handle-tx"><a href="#handle-tx" class="headerlink" title="handle_tx"></a>handle_tx</h2><p>底层驱动的发送中断函数，负责从circ_buf中取数据，然写入寄存器将数据发送到硬件端口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_tx</span><span class="params">(struct uart_port *port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">circ_buf</span> *<span class="title">xmit</span> = &amp;<span class="title">port</span>-&gt;<span class="title">state</span>-&gt;<span class="title">xmit</span>;</span></span><br><span class="line">	<span class="keyword">int</span> tx_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> tf_pointer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	tx_count = uart_circ_chars_pending(xmit);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (tf_pointer &lt; tx_count)  &#123;</span><br><span class="line">		<span class="comment">//循环从xmit.buf中取数据并发送出去</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//数据发完后，circ_buf中没有写入新的数据，则xmit会为空，此时将硬件中断关闭</span></span><br><span class="line">	<span class="keyword">if</span> (uart_circ_empty(xmit))</span><br><span class="line">		msm_hsl_stop_tx(port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uart_circ_chars_pending(xmit) &lt; WAKEUP_CHARS) &#123;</span><br><span class="line">		<span class="comment">//如果circ_buf中为的数据少于临界值了，则唤醒正在等待的进程，告诉它可以继续写数据了</span></span><br><span class="line">		uart_write_wakeup(port);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送流程"><a href="#发送流程" class="headerlink" title="发送流程"></a>发送流程</h2><p>到此为止，整个发送流程已经梳理完毕，附上流程图</p>
<img src="/Linux系统/linux串口驱动/uart_write.png">
<h1 id="read-uart，串口读流程"><a href="#read-uart，串口读流程" class="headerlink" title="read uart，串口读流程"></a>read uart，串口读流程</h1><p>包含2部分</p>
<ul>
<li><p>open uart时，底层驱动会打开串口的接收功能，硬件接收到数据后会调用rx中断服务函数，数据的入口既是中断服务函数：</p>
<p>handle_rx<br>​    tty_insert_flip_xx<br>​        flush_to_ldisc<br>​            n_tty_receive_buf2</p>
</li>
<li><p>应用层读取串口数据</p>
<p>tty_read<br>​    n_tty_read<br>​        copy_from_read_buf</p>
</li>
</ul>
<h2 id="handle-rx"><a href="#handle-rx" class="headerlink" title="handle_rx"></a>handle_rx</h2><p>底层驱动的接收中断函数，负责从硬件FIFO中读取数据然后写入到驱动层的buf中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_rx</span><span class="params">(struct uart_port *port, <span class="keyword">unsigned</span> <span class="keyword">int</span> misr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span> = <span class="title">port</span>-&gt;<span class="title">state</span>-&gt;<span class="title">port</span>.<span class="title">tty</span>;</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从硬件读取当前FIFO中有多少数据</span></span><br><span class="line">	<span class="keyword">if</span> (misr &amp; UARTDM_ISR_RXSTALE_BMSK) &#123;</span><br><span class="line">		count = msm_hsl_read(port,</span><br><span class="line">			regmap[vid][UARTDM_RX_TOTAL_SNAP]) -</span><br><span class="line">			msm_hsl_port-&gt;old_snap_state;</span><br><span class="line">		msm_hsl_port-&gt;old_snap_state = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		count = <span class="number">4</span> * (msm_hsl_read(port, regmap[vid][UARTDM_RFWR]));</span><br><span class="line">		msm_hsl_port-&gt;old_snap_state += count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* and now the main RX loop */</span></span><br><span class="line">	<span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> c;</span><br><span class="line">		<span class="comment">//循环将FIFO中的数据读取出来，放到驱动层的buf中</span></span><br><span class="line">		<span class="comment">/* <span class="doctag">TODO:</span> handle sysrq */</span></span><br><span class="line">		<span class="comment">/* if (!uart_handle_sysrq_char(port, c)) */</span></span><br><span class="line">		tty_insert_flip_string(tty-&gt;port, (<span class="keyword">char</span> *) &amp;c,</span><br><span class="line">				       (count &gt; <span class="number">4</span>) ? <span class="number">4</span> : count);</span><br><span class="line">		count -= <span class="number">4</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//唤醒处理接收buf的工作队列</span></span><br><span class="line">	tty_flip_buffer_push(tty-&gt;port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##flush_to_ldisc</p>
<p>flush_to_ldisc会调用 n_tty_receive_buf2处于接收到的数据，代码比较复杂，只做简单的功能众介绍</p>
<ul>
<li>检查n_tty_data的可用空间，如果应用层没有及时将数据读走，则不会从驱动层读取数据，同时做流控制操作</li>
<li>有可用空间的情况下，会将驱动层的数据读取到n_tty_data中</li>
<li>根据当前tty的模式，会将接收到的数据做转换处理，要完成终端协议，这里的处理会比较多</li>
<li>唤醒应用层的读取挂起进程</li>
</ul>
<p>##tty_read</p>
<p>功能相对比较简,tty_read调用n_tty_read（<em>同样只将重要部分展现出来</em>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">n_tty_read</span><span class="params">(struct tty_struct *tty, struct file *file,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">unsigned</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">n_tty_data</span> *<span class="title">ldata</span> = <span class="title">tty</span>-&gt;<span class="title">disc_data</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> __user *b = buf;</span><br><span class="line">	DECLARE_WAITQUEUE(wait, current);</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">int</span> minimum, time;</span><br><span class="line">	<span class="keyword">ssize_t</span> retval = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> timeout;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> packet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据termios.c_cc[VTIME]和termios.c_cc[VMIN]计算出单次读取操作的超时时间</span></span><br><span class="line">	minimum = time = <span class="number">0</span>;</span><br><span class="line">	timeout = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">	<span class="keyword">if</span> (!ldata-&gt;icanon) &#123;</span><br><span class="line">		minimum = MIN_CHAR(tty);</span><br><span class="line">		<span class="keyword">if</span> (minimum) &#123;</span><br><span class="line">			time = (HZ / <span class="number">10</span>) * TIME_CHAR(tty);</span><br><span class="line">			<span class="keyword">if</span> (time)</span><br><span class="line">				ldata-&gt;minimum_to_wake = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!waitqueue_active(&amp;tty-&gt;read_wait) ||</span><br><span class="line">				 (ldata-&gt;minimum_to_wake &gt; minimum))</span><br><span class="line">				ldata-&gt;minimum_to_wake = minimum;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			timeout = (HZ / <span class="number">10</span>) * TIME_CHAR(tty);</span><br><span class="line">			ldata-&gt;minimum_to_wake = minimum = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	packet = tty-&gt;packet;</span><br><span class="line">	<span class="comment">//如果没有数据可读取，当前进程挂起，通过read_wait来唤醒</span></span><br><span class="line">	add_wait_queue(&amp;tty-&gt;read_wait, &amp;wait);</span><br><span class="line">	<span class="keyword">while</span> (nr) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!input_available_p(tty, <span class="number">0</span>)) &#123;</span><br><span class="line">				<span class="comment">//如果没有数据，则挂起进程</span></span><br><span class="line">				timeout = schedule_timeout(timeout);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//copy_from_read_buf：从n_tty_data数据结构中读取数据</span></span><br><span class="line">			uncopied = copy_from_read_buf(tty, &amp;b, &amp;nr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取流程"><a href="#读取流程" class="headerlink" title="读取流程"></a>读取流程</h2><p>到此为止，整个接收流程已经梳理完毕，附上流程图</p>
<img src="/Linux系统/linux串口驱动/uart_read.png"></div><div class="tags"><a href="/tags/linux驱动/">linux驱动</a><a href="/tags/串口/">串口</a><a href="/tags/tty/">tty</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/深度学习/Caffe笔记/" class="pre">Caffe笔记</a><a href="/芯片方案/imx6/imx6ull方案研究_软件篇/" class="next">i.MX 6ULL研究笔记_软件篇</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#整体框图"><span class="toc-text">整体框图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UART驱动注册"><span class="toc-text">UART驱动注册</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#uart-driver数据结构"><span class="toc-text">uart_driver数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uart-register-driver注册驱动"><span class="toc-text">uart_register_driver注册驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uart-port数据结构"><span class="toc-text">uart_port数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uart-add-one-port-添加串口"><span class="toc-text">uart_add_one_port 添加串口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各数据结构的关系"><span class="toc-text">各数据结构的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#open-uart，打开串口"><span class="toc-text">open uart，打开串口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#申请tty-struct"><span class="toc-text">申请tty_struct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#n-tty"><span class="toc-text">n_tty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uart-open"><span class="toc-text">uart_open</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各数据结构的关系-1"><span class="toc-text">各数据结构的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#write-uart，串口写流程"><span class="toc-text">write uart，串口写流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tty-write"><span class="toc-text">tty_write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uart-write"><span class="toc-text">uart_write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uart-start"><span class="toc-text">uart_start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handle-tx"><span class="toc-text">handle_tx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#发送流程"><span class="toc-text">发送流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#read-uart，串口读流程"><span class="toc-text">read uart，串口读流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#handle-rx"><span class="toc-text">handle_rx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读取流程"><span class="toc-text">读取流程</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/芯片方案/mdm9x07/QMI 拨号&网口/">QMI 拨号&网口</a></li><li class="post-list-item"><a class="post-list-link" href="/Linux系统/linux USB host 驱动/">linux USB host驱动</a></li><li class="post-list-item"><a class="post-list-link" href="/Linux系统/linux USB gadget 驱动/">linux gadget 驱动</a></li><li class="post-list-item"><a class="post-list-link" href="/Linux系统/cmdline初始流程/">cmdline初始流程</a></li><li class="post-list-item"><a class="post-list-link" href="/Linux系统/linux根文件系统挂载过程/">linux根文件系统挂载过程</a></li><li class="post-list-item"><a class="post-list-link" href="/芯片方案/mdm9x07/mdm9x07内存使用分析/">mdm9x07内存使用分析</a></li><li class="post-list-item"><a class="post-list-link" href="/allegro/allegro/">allegro/allegro</a></li><li class="post-list-item"><a class="post-list-link" href="/深度学习/TensorFlow笔记/">TensorFlow笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/深度学习/MTCNN tensorflow实现/">MTCNN tensorflow实现</a></li><li class="post-list-item"><a class="post-list-link" href="/深度学习/Caffe笔记/">Caffe笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ARM架构/">ARM架构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux内核/">linux内核</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/uboot/">uboot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/深度学习/">深度学习</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/芯片方案/">芯片方案</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/中断/" style="font-size: 15px;">中断</a> <a href="/tags/cmdline/" style="font-size: 15px;">cmdline</a> <a href="/tags/USB/" style="font-size: 15px;">USB</a> <a href="/tags/rootfs/" style="font-size: 15px;">rootfs</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/caffe2/" style="font-size: 15px;">caffe2</a> <a href="/tags/MTCNN/" style="font-size: 15px;">MTCNN</a> <a href="/tags/tensorflow/" style="font-size: 15px;">tensorflow</a> <a href="/tags/arm/" style="font-size: 15px;">arm</a> <a href="/tags/uboot/" style="font-size: 15px;">uboot</a> <a href="/tags/linux驱动/" style="font-size: 15px;">linux驱动</a> <a href="/tags/串口/" style="font-size: 15px;">串口</a> <a href="/tags/tty/" style="font-size: 15px;">tty</a> <a href="/tags/TensorFlow/" style="font-size: 15px;">TensorFlow</a> <a href="/tags/环境搭建/" style="font-size: 15px;">环境搭建</a> <a href="/tags/芯片资料/" style="font-size: 15px;">芯片资料</a> <a href="/tags/mdm9x07/" style="font-size: 15px;">mdm9x07</a> <a href="/tags/imx6/" style="font-size: 15px;">imx6</a> <a href="/tags/rmmnet/" style="font-size: 15px;">rmmnet</a> <a href="/tags/QMI/" style="font-size: 15px;">QMI</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">wzhchen.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>